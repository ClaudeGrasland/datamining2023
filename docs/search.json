[
  {
    "objectID": "23-CARTO-leaflet.html",
    "href": "23-CARTO-leaflet.html",
    "title": "Carto-leaflet",
    "section": "",
    "text": "library(knitr)\n## Global options\noptions(max.print=\"80\")\nopts_chunk$set(echo=TRUE,\n               cache=FALSE,\n               prompt=FALSE,\n               tidy=FALSE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE,\n               options(scipen=999))\nopts_knit$set(width=75)\n\n# Packages utilitaires\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(rmdformats)\n\n# Packages graphiques\nlibrary(ggplot2)\nlibrary(RColorBrewer)\n\n#packages cartographiques \nlibrary(sf)\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\nlibrary(leaflet)\nlibrary(htmlwidgets)\nlibrary(htmltools)\n\n# Appel d'API\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(geojsonsf)"
  },
  {
    "objectID": "23-CARTO-leaflet.html#premiers-pas",
    "href": "23-CARTO-leaflet.html#premiers-pas",
    "title": "Carto-leaflet",
    "section": "Premiers pas",
    "text": "Premiers pas\n\nOBJECTIFS : Ce premier cours propose de fournir les bases élémentaires du logiciel Leaflet. Il est très largement inspiré d’un article d’Elena Salette publié sur l’excellent site de formation ThinkR et intitulé Cartographie interactive : comment visualiser mes données spatiales de manière dynamique avec leaflet ?\n\n\nBUG WARNING : Il peut arriver que la transformation du fichier .Rmd en .html ne s’opère pas et que vous voyiez apparaître le message d’erreur suivant RMarkdown cannot knit: html_dependency not found. Ce message d’erreur persiste même après avoir corrigé le code… ce qui est très pénible. Après avoir cherché sur les forums de discussion, j’ai trouvé une première réponse sur stackoverflow qui consiste simplement à aller sur la flèche descendnate à droite du bouton knitr et effectuer un clear knitr cache avant de relancer le Knitr. Apparemment ça marche, sans que je sache bien pourquoi. Mais la solution la plus efficace semble être d’insérer une option cache=FALSE dans les options globales du fichier Markdown. Cela va sans doute un peu ralentir l’affichage des pages HTML,mais évite les problèmes. On pourra toujours rétablir cache=TRUE si nécessaire\n\nNotre premier objectif très limité sera de construire une carte interactive utilisant le fonds de carte OpenStreetMap que l’on pourra zoomer en avant ou en arrière. La carte comportera la localisation de la place de la gare à Sucy-en-Brie avec une “épingle” de localisation comportant une photographie de la gare et un petit texte de promotion de celle-ci.\n\nLancement avec leaflet()\nNous allons avoir besoin des packages suivants :\n\nleaflet puisque c’est l’objet même du cours !\ndplyr afin de pouvoir construire des programmes utilisant des pipes %>%\nsf pour charger des fonds de carte de différents types (points, lignes polygones)\nhtmltools et htmlwidgets pour ajouter des popups interactifs sur notre carte\n\nPour vérifier que le package leaflet est bien installé, nous créons une première carte (vide !)\n\nmap <- leaflet()\n\nmap\n\n\n\n\n\nEt il n’y a … RIEN ! si ce n’est un bouton de zoom\n\n\nRemplissage avec addTiles()\nOn ajoute sur ce fond de carte vide des “tuiles” cartographiques qui sont des images se modifiant selon l’échelle pour apporter plus ou moins de détails. Par défaut, le fonds de carte de référence est le fonds OpenStreetMap\n\nlibrary(leaflet)\n\nmap <- leaflet() %>%\n          addTiles()\n\nmap\n\n\n\n\n\nLa carte est désormais interactive et on peut effectuer des zooms ou se déplacer.\n\n\nCalage avec setView()\nNous allons ensuite choisir un point de référence, par exemple la place de la gare à Sucy-en-Brie. Pour trouver les coordonnées de latitude et longitude, la solution la plus simple est d’utiliser Google Maps puis de zoomer sur la zone d’étude et enfin d’effectuer un click droit avec la souris sur le point dont on cherche les coordonnées pour obtenir dans un popup les coordonnées recherchées :\n On peut alors procéder à une double opération de centrage de notre carte et de définition d’une échelle d’observation afin que la carte produite par leafletcouvre bien la zone qui nous intéresse. Cette double opération est réalisée à l’aide de la fonction setView() assortie des trois paramètre suivants :\n\nlng = pour la longitude\nlat = pour la latitude\nzoom = pour le degré d’aggrandissement de la carte de 1 pour le Monde entier à 20 pour une vision ulra locale\n\n\nmap <- leaflet() %>% \n          addTiles() %>%\n          setView(lat = 48.77141, lng=2.50870, zoom = 17)\n\nmap\n\n\n\n\n\nUne fois qu’on a vérifié le centrage avec un zoom fort (ici 17), on peut refaire la carte en utilisant un zoom plus faible, par exemple un zoom de 12 permettant de visualiser toute la commune de Sucy et les communes voisines.\n\nmap <- leaflet() %>% \n          addTiles() %>%\n          setView(lat = 48.77141, lng=2.50870, zoom = 12)\n\nmap\n\n\n\n\n\n\n\nPersonalisation avec addProviderTiles()\nLes tuiles OpenStreetMap qui servent de fonds de carte par défaut peuvent être remplacés par des tuiles personalisées fournies par des producteurs publics ou privés. On peut obtenir la liste des tuiles disponibles en tapant providers dans la console de R studio et les tester une par une. Mais il est souvent plus simple et plus rapide d’aller visualiser les tuiles disponibles sur ce site web où l’on peut centrer le monde sur sa zone d’étude et voir ce que donnent les différentes familles de tuiles.\nA titre d’exemple, les tuiles Stamen.Watercolor donnent une touche pastel artistique à la carte :\n\nmap <- leaflet() %>% \n            addProviderTiles('Stamen.Watercolor') %>%\n          setView(lat = 48.77141, lng=2.50870, zoom = 12)\n\nmap\n\n\n\n\n\nTandis que la couche Esri.WorldTopoMap fournit une imagerie précise mais de couleurs plus neutre que les tuiles OpenStreetMap , ce qui sera intéressant si on superspose des marqueurs de couleur vive.\n\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n          setView(lat = 48.77141, lng=2.50870, zoom = 12)\nmap\n\n\n\n\n\n\n\nAffichage d’un point avec addMarkers()\nL’usage le plus fréquent de leafletconsiste à ajouter des éléments de localisation ponctuelle appelés markerset de rendre ces objets ponctuels interactifs avec l’ouverture de fenêtres popupslorsqu’on clique dessus avec la souris. On va donc voir pas à pas comment construire de telles cartes interactives en partant du cas le plus simple (marqueur unique) pour aller vers les cas plus complexes (ensemble de marqueurs de taille, couleur et formes différentes).\nNous allons commencer par indiquer l’emplacement de la place de la gare de Sucy-en-Brie sur notre carte précédente à l’aide de la fonction addMarkers() :\n\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.77141, lng=2.50870, zoom = 12) %>% \n            addMarkers(lat = 48.77141, lng=2.50870)\nmap\n\n\n\n\n\nOn constate que le marqueur donne bien la position choisi mais n’est pas interactif. Il faut ajouter plus de paramètres pour assurer l’interactivité.\n\n\nAjout d’un labelou d’un popup\nOn peut définir deux comportements d’un marker selon que la souris ne fait que passer dessus (label) ou selon que l’utilisateur effectue un click sur marker et déclenche l’ouverture d’une fenêtre (popup). Dans sa version la plus simple, l’interactivité consiste à ajouter une chaîne de caractère à ces deux paramètres.\n\nicone_gare <-makeIcon(iconUrl = \"img/gare_sucy_coord_googlemap.png\")\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.77141, lng=2.50870, zoom = 12) %>% \n            addMarkers(lat = 48.77141, lng=2.50870,\n                      # En passant la souris\n                      label = \"GARE DE SUCY-BONNEUIL\", \n                      # En cliquant sur l'icone\n                       popup = \"La gare RER A de Sucy Bonneuil est bien reliée aux communes \n                                 environnantes par un réseau de bus partant dans toutes les directions\")\nmap\n\n\n\n\n\n\n\nAmélioration du popup\nMais on peut faire beaucoup mieux, notamment pour la fenêtre popupqui peut prendre la forme d’une mini-page web dont on fixe le contenu en html avec la fonction paste0() et les dimensions avec le sous-paramètre popupOptions().\n\n# Préparation de la fenêtre Popup\n    my_popup = paste0(\n      \"<b> LA GARE DE SUCY\",\n      \"</b><br/><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Gare_Sucy-en-Brie.jpg/1200px-Gare_Sucy-en-Brie.jpg width='200px'><br/>\",\n      \"La gare RER A de Sucy Bonneuil est bien reliée aux communes \n                                 environnantes par un réseau de bus partant dans toutes les directions.\")\n\n\n  \n# Réalisation de la carte\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.77141, lng=2.50870, zoom = 12) %>% \n            addMarkers(lat = 48.77141, lng=2.50870,\n                      # En passant la souris\n                      label = \"GARE DE SUCY-BONNEUIL\", \n                      # En cliquant sur l'icone\n                       popup = my_popup, \n                      # Quelques options de la popup\n                        popupOptions = \n                      list(maxHeight = 150, maxWidth = 200))\nmap\n\n\n\n\n\n\n\nProlongements\nEt voila, le tour est joué. Il faut maintenant réfléchir à la façon de construire une carte comportant un ensemble d’épingles similaires avec des couleurs ou des formes différentes, des messages différents, des photographies variées … Il ne sera alors évidemment pas possible d’ajouter une commande addMarkers() pour chaque épingle si la carte en comporte des centaines.\nSi vous avez bien compris ce cours, vous pourrez trouver des réponses en lisant de façon autonome le reste de l’article dont nous nous somme inspiré : Cartographie interactive : comment visualiser mes données spatiales de manière dynamique avec leaflet ?"
  },
  {
    "objectID": "23-CARTO-leaflet.html#cartographie-de-points",
    "href": "23-CARTO-leaflet.html#cartographie-de-points",
    "title": "Carto-leaflet",
    "section": "Cartographie de points",
    "text": "Cartographie de points\nNous allons prendre comme exemple la cartographie des ventes de maisons issues de la base de données dvf qui a fait l’objet du cours.\n\nPréparation des données\nOn télécharge à titre d’exemple les ventes de maison à Sucy-en-Brie en 2020 en ne conservant que celles pour lesquelles on dispose de la surface du logement et de celle du terrain.\n\n x<-GET(\"https://public.opendatasoft.com//api/records/1.0/search/?dataset=buildingref-france-demande-de-valeurs-foncieres-geolocalisee-millesime&q=&rows=10000&facet=date_mutation&facet=nature_mutation&facet=com_code&facet=type_local&refine.date_mutation=2020&refine.nature_mutation=Vente&refine.type_local=Maison&refine.com_code=94071\")\n\nw<-rawToChar((x$content))\nd<-fromJSON(w)\nt<-d$records$fields\n\nsel<-t %>% select(latitude,\n                  longitude,\n                  nbp=nombre_pieces_principales,\n                  surf_bat=surface_reelle_bati,\n                  surf_ter = surface_terrain,\n                  val = valeur_fonciere) %>% \n          mutate(prixm2 = val/surf_bat)\n\nsel<-sel[complete.cases(sel)==T,]\n\nkable(head(sel))\n\n\n\n\n\nlatitude\nlongitude\nnbp\nsurf_bat\nsurf_ter\nval\nprixm2\n\n\n\n\n1\n48.77354\n2.512549\n4\n82\n559\n624000\n7609.756\n\n\n2\n48.76200\n2.523487\n3\n60\n585\n364000\n6066.667\n\n\n3\n48.75630\n2.537520\n4\n63\n403\n321905\n5109.603\n\n\n5\n48.76630\n2.527617\n4\n121\n244\n422850\n3494.628\n\n\n8\n48.76309\n2.511682\n6\n150\n617\n669000\n4460.000\n\n\n9\n48.76588\n2.512032\n4\n94\n378\n477000\n5074.468\n\n\n\n\nsummary(sel)\n\n    latitude       longitude          nbp            surf_bat    \n Min.   :48.76   Min.   :2.508   Min.   : 1.000   Min.   : 20.0  \n 1st Qu.:48.76   1st Qu.:2.515   1st Qu.: 4.000   1st Qu.: 81.0  \n Median :48.77   Median :2.521   Median : 5.000   Median :110.0  \n Mean   :48.77   Mean   :2.525   Mean   : 4.775   Mean   :118.2  \n 3rd Qu.:48.77   3rd Qu.:2.532   3rd Qu.: 6.000   3rd Qu.:146.0  \n Max.   :48.78   Max.   :2.561   Max.   :11.000   Max.   :384.0  \n    surf_ter           val             prixm2       \n Min.   :  40.0   Min.   :100000   Min.   :  970.9  \n 1st Qu.: 324.0   1st Qu.:370000   1st Qu.: 3687.2  \n Median : 400.0   Median :468500   Median : 4263.2  \n Mean   : 451.5   Mean   :488648   Mean   : 4614.2  \n 3rd Qu.: 530.0   3rd Qu.:580000   3rd Qu.: 5185.2  \n Max.   :1375.0   Max.   :866140   Max.   :18538.2  \n\n\n\n\nCartographie des localisations\nOn commence par créer une carte des localisations des ventes de maison avec AddCircleMarkers()\n\n# Réalisation de la carte\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.77, lng=2.53, zoom = 13) %>%\n  \n             addCircleMarkers(data=sel,\n                              lat = ~latitude,\n                              lng = ~longitude)\n\nmap\n\n\n\n\n\n\n\nRéglage de la taille des cercles\nOn règle la taille des cercles en fonction du nombre de pièces\n\n# Calcul du diamètre des cercles\n  sel$myradius <-10*sqrt(sel$nbp/max(sel$nbp,na.rm=T))\n  \n# Réalisation de la carte\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.77, lng=2.53, zoom = 13) %>%\n  \n             addCircleMarkers(data=sel,\n                              lat = ~latitude,\n                              lng = ~longitude,\n                              radius= ~myradius,    # diamètre\n                              stroke=FALSE,         # pas de bordure           \n                              fillOpacity = 0.5)    # opacité \n            \n                              \n\nmap\n\n\n\n\n\n\n\nRéglage de la couleur des cercles\nOn fait varier la couleur des cercles en fonction du prix au m2\n\n# Calcul du diamètre des cercles\n  sel$myradius <-10*sqrt(sel$nbp/max(sel$nbp,na.rm=T))\nsummary(sel$prixm2)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  970.9  3687.2  4263.2  4614.2  5185.2 18538.2 \n\n# Choix des classes \n    mycut<-round(quantile(sel$prixm2,probs = c(0,0.2,0.4,0.6,0.8,1)),0)\n    \n# Choix de la palette (c'est une fonction !)\n   mypal <- colorBin('Spectral', \n                       reverse = T,\n                       sel$prixm2,\n                       bins=mycut)\n  \n# Réalisation de la carte\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.77, lng=2.53, zoom = 13) %>%\n  \n             addCircleMarkers(data=sel,\n                              lat = ~latitude,\n                              lng = ~longitude,\n                              \n                              radius= ~myradius,    # diamètre\n                              \n                              stroke=TRUE,          # bordure   \n                              weight=1  ,           # épaisseur de la bordure\n                              color= \"black\",      # couleur de la bordure\n                              opacity = 0.7  ,       # opacité de la bordure \n                              \n                              fillOpacity = 0.5,    # opacité \n                              fillColor = ~mypal(prixm2)\n                              )    %>%\n              addLegend(data = sel,\n                      pal = mypal, \n                      title = \"Prix / m2\",\n                      values =~prixm2, \n                      position = 'topright') \n            \n                              \n\nmap\n\n\n\n\n\n\n\nAjout d’un popup d’information\nOn rajoute un popup pour afficher toutes les informations sur chaque vente\n\n# Calcul du diamètre des cercles\n  sel$myradius <-10*sqrt(sel$nbp/max(sel$nbp,na.rm=T))\n\n# Choix des classes \n    mycut<-round(quantile(sel$prixm2,probs = c(0,0.2,0.4,0.6,0.8,1)),0)\n    \n# Choix de la palette (c'est une fonction !)\n   mypal <- colorBin('Spectral', \n                       reverse = T,\n                       sel$prixm2,\n                       bins=mycut)\n  \n   \n   \n # Préparation des popups\n      mypopups <- lapply(seq(nrow(sel)), function(i) {\n      paste0(  paste(\"Prix de vente       : \" ,sel$val[i]), '<br>', \n               paste(\"Nb. de pièces       : \" ,sel$nbp[i]), '<br>', \n               paste(\"Surface du logement : \", sel$surf_bat[i]), '<br>',\n               paste(\"Surface du terrain  : \" ,round(sel$surf_ter[i],1)))\n            \n            })\n      mypopups<-lapply(mypopups, htmltools::HTML)  \n\n   \n  \n# Réalisation de la carte\nmap <- leaflet() %>% \n           addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.77, lng=2.53, zoom = 13) %>%\n             addCircleMarkers(data=sel,\n                              lat = ~latitude,\n                              lng = ~longitude,\n                              \n                              radius= ~myradius,    # diamètre\n                              \n                              stroke=TRUE,          # bordure   \n                              weight=1  ,           # épaisseur de la bordure\n                              color= \"black\",      # couleur de la bordure\n                              opacity = 0.7  ,       # opacité de la bordure \n                              \n                              fillOpacity = 0.5,    # opacité \n                              fillColor = ~mypal(prixm2),\n                              \n                             popup = mypopups,\n                              )    %>%\n              addLegend(data = sel,\n                      pal = mypal, \n                      title = \"Prix au m2\",\n                      values =~prixm2, \n                      position = 'topright') \n            \n                              \n\nmap\n\n\n\n\n\n\n\nChoix des tuiles\nOn fait varier les tuiles pour offrir la possibilité de visualiser la position des maisons sur un plan ou sur une photo aérienne.\n\n# Calcul du diamètre des cercles\n  sel$myradius <-10*sqrt(sel$nbp/max(sel$nbp,na.rm=T))\nsummary(sel$prixm2)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  970.9  3687.2  4263.2  4614.2  5185.2 18538.2 \n\n# Choix des classes \n    mycut<-round(quantile(sel$prixm2,probs = c(0,0.2,0.4,0.6,0.8,1)),0)\n    \n# Choix de la palette (c'est une fonction !)\n   mypal <- colorBin('Spectral', \n                       reverse = T,\n                       sel$prixm2,\n                       bins=mycut)\n  \n   \n   \n # Préparation des popups\n      mypopups <- lapply(seq(nrow(sel)), function(i) {\n      paste0(  paste(\"Prix de vente       : \" ,sel$val[i]), '<br>', \n               paste(\"Nb. de pièces       : \" ,sel$nbp[i]), '<br>', \n               paste(\"Surface du logement : \", sel$surf_bat[i]), '<br>',\n               paste(\"Surface du terrain  : \" ,round(sel$surf_ter[i],1)))\n            \n            })\n      mypopups<-lapply(mypopups, htmltools::HTML)  \n\n   \n  \n# Réalisation de la carte\nmap <- leaflet() %>% \n               # Tuiles\n               addTiles(group = \"OSM \") %>%\n               addProviderTiles('Esri.WorldTopoMap', group = \"ESRI topo.\") %>%\n               addProviderTiles('Esri.WorldImagery', group = \"ESRI photo.\") %>%\n              # Contrôle des tuiles\n               addLayersControl( baseGroups = c(\"OSM\",\"ESRI topo.\",\"ESRI photo.\"),\n                                 position = \"bottomright\") %>%\n            setView(lat = 48.77, lng=2.53, zoom = 13) %>%\n             addCircleMarkers(data=sel,\n                              lat = ~latitude,\n                              lng = ~longitude,\n                              \n                              radius= ~myradius,    # diamètre\n                              \n                              stroke=TRUE,          # bordure   \n                              weight=1  ,           # épaisseur de la bordure\n                              color= \"black\",      # couleur de la bordure\n                              opacity = 0.7  ,       # opacité de la bordure \n                              \n                              fillOpacity = 0.5,    # opacité \n                              fillColor = ~mypal(prixm2),\n                              \n                             popup = mypopups,\n                              )    %>%\n              addLegend(data = sel,\n                      pal = mypal, \n                      title = \"Prix au m2\",\n                      values =~prixm2, \n                      position = 'topright') \n            \n                              \n\nmap\n\n\n\n\n\n\n\nExercice n°1\nConstruire une carte interactive des ventes d’appartement dans le 13e arrondissement en 2021 en adaptant légèrement le programme précédent (en particulier : ne plus retenir la surface du terrain)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      0    8540    9889   14891   11538  683333 \n\n\n\n\n\n\n\n\nExercice n°2\nEn repartant du programme précédent, construire une fonction d’affichage cartographique du prix des appartements pour n’importe quel code INSEE et n’importe quelle date.\n\n\n\nOn applique au 16e arrondissemen en 2018\n\nvisu_appart(\"75116\",\"2018\")\n\n\n\n\n\nOn applique à Fontenay-Sous-Bois en 2015 :\n\nvisu_appart(\"94033\",\"2015\")\n\n\n\n\n\n\n\nExercice n°3\nQuels sont les avantages et inconvénients du téléchargement interactif des données à l’aide d’une API ?\nCommet pourriez vous procéder pour obtenir une fonction d’affichage plus rapide ?"
  },
  {
    "objectID": "11-API-OPENDATASOFT.html",
    "href": "11-API-OPENDATASOFT.html",
    "title": "L’API opendatasoft",
    "section": "",
    "text": "L’objectif de ce chapitre est d’examiner en détail le fonctionnement du site public.opendatasoft qui permet d’accèder à des centaines d’API à l’aide de requêtes normalisées. Sans apprendre en détail le fonctionnement de cette API, on va montrer comment créer de petites fonctions facilitant le travail d’exportation des variables ou des données.\nOn charge les packages utiles :"
  },
  {
    "objectID": "11-API-OPENDATASOFT.html#liste-des-api",
    "href": "11-API-OPENDATASOFT.html#liste-des-api",
    "title": "L’API opendatasoft",
    "section": "Liste des API",
    "text": "Liste des API\nLa première étape consiste à choisir l’API qui nous intéresse parmi plus de 600.\n\nEn parcourant le site\nOn peut se rendre sur le site pour parcourir les API proposées en allant à l’adresse : https://public.opendatasoft.com\n\n\n\n\n\n\n\nEn récupérant le catalogue\nMais il est également possible de téécharger le catalogue général … en se servant d’une API\n\nx<-GET('https://public.opendatasoft.com/api/datasets/1.0/search/?q=&rows=1000&start=0')\ny<-fromJSON(rawToChar((x$content)))\ncat<-y$datasets$metas\nrow.names(cat)<-y$datasets$datasetid\nkable(head(cat[,c(12,1,6,7,8)]),row.names = F)\n\n\n\n\n\n\n\n\n\n\n\nlicense_url\ndomain\nmodified\nlicense\npublisher\n\n\n\n\nhttps://creativecommons.org/licenses/by/4.0/\npublic\n2022-12-14T10:45:09+00:00\nCC BY 4.0\nOpendatasoft\n\n\nhttps://www.etalab.gouv.fr/wp-content/uploads/2014/05/Licence_Ouverte.pdf\npublic\n2015-12-09T11:06:48+00:00\nOpen License v1.0\nMinistère de l’Intérieur\n\n\nhttps://www.etalab.gouv.fr/wp-content/uploads/2014/05/Licence_Ouverte.pdf\npublic\n2015-12-11T14:08:02+00:00\nLicence Ouverte v1.0\nCAF\n\n\nhttps://en.wikipedia.org/wiki/Public_domain\npublic\n2019-03-06T10:33:30+00:00\nPublic domain\nDirection Générale des Collectivités Locales (DGCL)\n\n\nhttps://www.etalab.gouv.fr/wp-content/uploads/2014/05/Licence_Ouverte.pdf\npublic\n2018-10-03T17:49:09+00:00\nLicence Ouverte v1.0\nAgence de services et de paiement (ASP)\n\n\nhttps://www.etalab.gouv.fr/wp-content/uploads/2018/11/open-licence.pdf\npublic\n2021-06-09T11:27:44+00:00\nOpen License v2.0\nDirection Générale des Collectivités Locales (DGCL)\n\n\n\n\n\nOn suppose que le choix s’est porté sur l’API arbresremarquablesparis2011"
  },
  {
    "objectID": "11-API-OPENDATASOFT.html#liste-des-variables-dune-api",
    "href": "11-API-OPENDATASOFT.html#liste-des-variables-dune-api",
    "title": "L’API opendatasoft",
    "section": "Liste des variables d’une API",
    "text": "Liste des variables d’une API\nAvant de télécharger les données, on effectue une requête pour connaître les variables du tableau que l’on va télécharger ainsi que les variables pouvant servir de “facettes” c’est-à-dire permettant d’effectuer des requêtes.\n\nProgramme\n\ntab<-\"arbresremarquablesparis2011\"\nurl<-paste(\"https://public.opendatasoft.com/api/v2/catalog/datasets/\",tab,\"?\",sep=\"\")\nx<-GET(url)\ny<-fromJSON(rawToChar(x$content))\nvar<-y$dataset$fields\n\nhead(var)\n\n             name           label   type annotations.facet\n1          idbase          IDBASE double                NA\n2 libellefrancais LIBELLEFRANCAIS   text              TRUE\n3           genre           GENRE   text              TRUE\n4          espece          ESPECE   text              TRUE\n5         adresse         ADRESSE   text                NA\n6 typeemplacement TYPEEMPLACEMENT   text                NA\n  annotations.hierarchical annotations.unit annotations.facetsort\n1                     <NA>             <NA>                  <NA>\n2                     <NA>             <NA>                  <NA>\n3                        /             <NA>                  <NA>\n4                        /             <NA>                  <NA>\n5                     <NA>             <NA>                  <NA>\n6                     <NA>             <NA>                  <NA>\n  annotations.timeserie_precision description\n1                            <NA>          NA\n2                            <NA>          NA\n3                            <NA>          NA\n4                            <NA>          NA\n5                            <NA>          NA\n6                            <NA>          NA\n\n\nLe tableau est correct, mais il présente une structure inhabituelle puisqu’on trouve un dataframe à l’intérieur de chaque ligne de la variable annotations. On va donc éviter les ennuis en ne gardant que les deux premières colonnes\n\nvar <- var  %>% select(-annotations)\nkable(var)\n\n\n\n\nname\nlabel\ntype\ndescription\n\n\n\n\nidbase\nIDBASE\ndouble\nNA\n\n\nlibellefrancais\nLIBELLEFRANCAIS\ntext\nNA\n\n\ngenre\nGENRE\ntext\nNA\n\n\nespece\nESPECE\ntext\nNA\n\n\nadresse\nADRESSE\ntext\nNA\n\n\ntypeemplacement\nTYPEEMPLACEMENT\ntext\nNA\n\n\ndomanialite\nDOMANIALITE\ntext\nNA\n\n\narrondissement\nARRONDISSEMENT\ntext\nNA\n\n\ncomplementadresse\nCOMPLEMENTADRESSE\ntext\nNA\n\n\nnumero\nNUMERO\ntext\nNA\n\n\nidemplacement\nIDEMPLACEMENT\ntext\nNA\n\n\ncirconferenceencm\nCIRCONFERENCE EN CM\ndouble\nNA\n\n\nhauteurenm\nHAUTEUR EN M\ndouble\nNA\n\n\nstadedeveloppement\nSTADEDEVELOPPEMENT\ntext\nNA\n\n\npepiniere\nPEPINIERE\ntext\nNA\n\n\nvarieteoucultivar\nVARIETE OU CULTIVAR\ntext\nNA\n\n\ndateplantation\nDATEPLANTATION\ndatetime\nNA\n\n\nremarquable\nREMARQUABLE\ntext\nNA\n\n\ngeom_x_y\nGeo point\ngeo_point_2d\nNA\n\n\n\n\n\n\n\nFonction\nOn le transforme en fonction pour un usage plus simple :\n\nget_variables<-function(idtab = \"arbresremarquablesparis2011\") {\n  url<-paste(\"https://public.opendatasoft.com/api/v2/catalog/datasets/\",idtab,\"?\",sep=\"\")\n  x<-GET(url)\n  y<-fromJSON(rawToChar((x$content)))\n  var<-y$dataset$fields\n  var <- var %>% select(-annotations)\n  return(var)\n}\n\nOn peut désormais appliquer notre fonction sur n’importe quel autre tableau du catalogue. Par exemple, si on choisit le tableau qualite_de-lair-france on obtient la liste de variables suivante :\n\nvar<-get_variables(\"qualite-de-lair-france\")\nkable(var)\n\n\n\n\nname\nlabel\ntype\ndescription\n\n\n\n\ncountry\nCountry Code\ntext\nNA\n\n\ncity\nCity\ntext\nNA\n\n\nlocation\nLocation\ntext\nNA\n\n\ncoordinates\nCoordinates\ngeo_point_2d\nNA\n\n\nmeasurements_parameter\nPollutant\ntext\nNA\n\n\nmeasurements_sourcename\nSource Name\ntext\nNA\n\n\nmeasurements_unit\nUnit\ntext\nNA\n\n\nmeasurements_value\nValue\ndouble\nNA\n\n\nmeasurements_lastupdated\nLast Updated\ndatetime\nNA\n\n\ncountry_name_en\nCountry Label\ntext\nNA"
  },
  {
    "objectID": "11-API-OPENDATASOFT.html#récupération-des-données",
    "href": "11-API-OPENDATASOFT.html#récupération-des-données",
    "title": "L’API opendatasoft",
    "section": "Récupération des données",
    "text": "Récupération des données\n\nProgramme\nPar défaut, une API renvoie 10 enregistrements, ce qui permet de se faire une première idée de la structure des données\n\n x<-GET(\"https://public.opendatasoft.com/api/records/1.0/search/?dataset=arbresremarquablesparis2011&q=&rows=10\")\ny<-fromJSON(rawToChar((x$content)))\n  don<-y$records$fields\nkable(don)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhauteurenm\ngeom_x_y\ncirconferenceencm\nstadedeveloppement\nremarquable\ngenre\npepiniere\ndateplantation\ntypeemplacement\narrondissement\ncomplementadresse\nidemplacement\nlibellefrancais\ndomanialite\nadresse\nespece\nidbase\nvarieteoucultivar\n\n\n\n\n30\n48.839405, 2.433374\n310\nMature\nOUI\nLiriodendron\nInconnue\n1862-01-01T00:09:21+00:00\nArbre\nBOIS DE VINCENNES\n12-02\n12-02\nTulipier\nJardin\nSQUARE CARNOT - AVENUE DAUMESNIL / ESPLANADE DU CHATEAU DE VINCENNES\ntulipifera\n2002370\nNA\n\n\n22\n48.868573, 2.313326\n209\nMature\nOUI\nCalocedrus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 8E ARRDT\nSecteur Marigny\n000103002\nLibocèdre\nJardin\nJARDINS DES CHAMPS ELYSEES - SQUARE MARIGNY / 41 AVENUE GABRIEL\ndecurrens\n307478\nNA\n\n\n6\n48.858754, 2.295499\n205\nAdulte\nOUI\nFagus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 7E ARRDT\nCanton 03 / SETE\nP00306006\nHêtre\nJardin\nJARDIN DU CHAMP DE MARS ET PELOUSES DE L ECOLE MILITAIRE / SETE\nsylvatica\n108183\n‘’Pendula’’\n\n\n20\n48.822604, 2.336701\n400\nMature\nOUI\nFagus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 14E ARRDT\nGrande pelouse\n031302006\nHêtre\nJardin\nPARC MONTSOURIS / 28 BOULEVARD JOURDAN\nsylvatica\n113328\n‘’Riversii’’\n\n\n12\n48.847611, 2.253143\n132\nAdulte\nOUI\nFirmiana\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 16E ARRDT\nNA\n00030001\nSterculier\nJardin\nJARDIN DES SERRES D AUTEUIL / 1 AVENUE GORDON BENNETT\nsimplex\n136446\nNA\n\n\n13\n48.857417, 2.314725\n155\nAdulte\nOUI\nMagnolia\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 7E ARRDT\n07-10\n000202001\nMagnolia\nJardin\nSQUARE D AJACCIO / 127 RUE DE GRENELLE\ngrandiflora\n109016\nNA\n\n\n7\n48.868295, 2.363189\n53\nJeune (arbre)\nOUI\nQuercus\nGUILLOT BOURNE\n2017-11-09T01:00:00+00:00\nArbre\nPARIS 10E ARRDT\nNA\n000401009\nChêne\nAlignement\nPLACE DE LA REPUBLIQUE\ncerris\n2017817\nNA\n\n\n30\n48.880335, 2.381305\n725\nMature\nOUI\nPlatanus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 19E ARRDT\n19-08\nH0690012\nPlatane\nJardin\nPARC DES BUTTES CHAUMONT\nx hispanica\n102141\nNA\n\n\n25\n48.863391, 2.240481\n468\nMature\nOUI\nCedrus\nInconnue\n1862-01-01T00:09:21+00:00\nArbre\nBOIS DE BOULOGNE\n16-09\n000301002\nCèdre\nJardin\nGRANDE CASCADE - CARREFOUR DE LONGCHAMP\nlibani\n2002348\nNA\n\n\n31\n48.87858, 2.30756\n645\nMature\nOUI\nPlatanus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 8E ARRDT\n08-02\n00SO0222\nPlatane\nJardin\nPARC MONCEAU\norientalis\n313940\nNA\n\n\n\n\n\n\n\nFonction\nOn peut ensuite écrire une fonction qui précise le nombre d’enregistrements à lire avec le paramètre raws= et le point de départ de la lecture avec le paramètre start= (sachant que le premier enregistrement correspond à la valeur 0). On pourra ensuite procéder à des téléchargements successifs en évitant de dépasser la valeur raws=10000 car en génral cela bloque le fonctionnement des API. Pour télécharger un tableau ayant plus de 10000 lignes, il faudra de préférence créer une boucle qui ramène des paquets de 10000.\n\nget_data<-function(idtab = \"arbresremarquablesparis2011\",\n                  rows=10,\n                  start=0) {\n  url<-paste0(\"https://public.opendatasoft.com/api/records/1.0/search/?dataset=\",idtab,\"&q=&rows=\",rows,\"&start=\",start,sep=\"\")\n  x<-GET(url)\n  y<-fromJSON(rawToChar((x$content)))\n  don<-y$records$fields\n  return(don)\n}\n\nDans le cas du tableau des arbres remarquables à paris, il n’y a que 178 enregistrements et il suffit donc de mettre une valeur de raws supérieure pour récupérer tout le tableau :\n\ndon_arbres <- get_data(idtab = \"arbresremarquablesparis2011\",\n                      rows=1000,\n                      start=0)\ndim(don_arbres)\n\n[1] 174  18\n\nkable(head(don_arbres))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhauteurenm\ngeom_x_y\ncirconferenceencm\nstadedeveloppement\nremarquable\ngenre\npepiniere\ndateplantation\ntypeemplacement\narrondissement\ncomplementadresse\nidemplacement\nlibellefrancais\ndomanialite\nadresse\nespece\nidbase\nvarieteoucultivar\n\n\n\n\n30\n48.839405, 2.433374\n310\nMature\nOUI\nLiriodendron\nInconnue\n1862-01-01T00:09:21+00:00\nArbre\nBOIS DE VINCENNES\n12-02\n12-02\nTulipier\nJardin\nSQUARE CARNOT - AVENUE DAUMESNIL / ESPLANADE DU CHATEAU DE VINCENNES\ntulipifera\n2002370\nNA\n\n\n22\n48.868573, 2.313326\n209\nMature\nOUI\nCalocedrus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 8E ARRDT\nSecteur Marigny\n000103002\nLibocèdre\nJardin\nJARDINS DES CHAMPS ELYSEES - SQUARE MARIGNY / 41 AVENUE GABRIEL\ndecurrens\n307478\nNA\n\n\n6\n48.858754, 2.295499\n205\nAdulte\nOUI\nFagus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 7E ARRDT\nCanton 03 / SETE\nP00306006\nHêtre\nJardin\nJARDIN DU CHAMP DE MARS ET PELOUSES DE L ECOLE MILITAIRE / SETE\nsylvatica\n108183\n‘’Pendula’’\n\n\n20\n48.822604, 2.336701\n400\nMature\nOUI\nFagus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 14E ARRDT\nGrande pelouse\n031302006\nHêtre\nJardin\nPARC MONTSOURIS / 28 BOULEVARD JOURDAN\nsylvatica\n113328\n‘’Riversii’’\n\n\n12\n48.847611, 2.253143\n132\nAdulte\nOUI\nFirmiana\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 16E ARRDT\nNA\n00030001\nSterculier\nJardin\nJARDIN DES SERRES D AUTEUIL / 1 AVENUE GORDON BENNETT\nsimplex\n136446\nNA\n\n\n13\n48.857417, 2.314725\n155\nAdulte\nOUI\nMagnolia\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 7E ARRDT\n07-10\n000202001\nMagnolia\nJardin\nSQUARE D AJACCIO / 127 RUE DE GRENELLE\ngrandiflora\n109016\nNA\n\n\n\n\n\nSi l’on prend l’exemple de la qualité de l’air, le tableau est nettement plus grand mais reste sous la valeur de 10000 enregistrements\n\ndon_air <- get_data(idtab = \"qualite-de-lair-france\",\n                      rows=10000,\n                      start=0)\ndim(don_air)\n\n[1] 1698   10\n\nkable(head(don_air))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmeasurements_unit\nmeasurements_value\ncoordinates\nmeasurements_sourcename\nmeasurements_lastupdated\nmeasurements_parameter\ncountry_name_en\ncountry\nlocation\ncity\n\n\n\n\nµg/m³\n11.9\n44.870262, 4.876289\nEEA France\n2023-03-19T01:00:00+00:00\nPM10\nFrance\nFR\nFR36001\nDrôme\n\n\nµg/m³\n0.0\n46.072219, 5.820832\nEEA France\n2023-03-17T11:00:00+00:00\nSO2\nFrance\nFR\nFR33302\nHaute-Savoie\n\n\nµg/m³\n1.5\n46.652645, 3.600663\nEEA France\n2023-03-19T03:00:00+00:00\nPM10\nFrance\nFR\nFR07022\nAllier\n\n\nµg/m³\n12.4\n-20.94977, 55.31385\nEEA France\n2023-03-19T03:00:00+00:00\nNO2\nFrance\nFR\nFR38018\nReunion\n\n\nµg/m³\n19.3\n43.793362, 7.331394\nEEA France\n2023-03-19T03:00:00+00:00\nPM10\nFrance\nFR\nFR24023\nAlpes-Maritimes\n\n\nµg/m³\n20.4\n50.957786, 1.890082\nEEA France\n2023-03-19T01:00:00+00:00\nPM10\nFrance\nFR\nFR10026\nPas-de-Calais\n\n\n\n\n\nPar contre la base SIRENE comporte 34 millions d’enregistrement et il va être impossible de la télécharger d’un coup à l’aide d’une API. Dès que la valeur rows dépasse 10000, l’API refuse de renvoyer les résultats\n\ndon_sir <- get_data(idtab = \"sirene_v3\",\n                      rows=10001,\n                      start=0)\ndim(don_sir)\n\nNULL"
  },
  {
    "objectID": "11-API-OPENDATASOFT.html#sélection-ou-exclusion",
    "href": "11-API-OPENDATASOFT.html#sélection-ou-exclusion",
    "title": "L’API opendatasoft",
    "section": "Sélection ou exclusion",
    "text": "Sélection ou exclusion\nL’intérêt principal d’une API est de procéder à des sélections d’enregistrement en amont de leur téléchargement. On va utiliser pour cela les facettes qui correspondent aux variables pour lesquelles l’API a prévu des index permettant une extraction rapide.\n\nSélection\nSupposons par exemple qu’on ne veuille extraire que les arbres remarquables de la famille des chênes (genre = Quercus). Cela correspond à l’ajout à la fin de l’instruction GET d’une instruction refine prenant ici la forme refine.genre=Quercus.\n\nx<- GET(\"https://public.opendatasoft.com/api/records/1.0/search/?dataset=arbresremarquablesparis2011&q=&rows=100&refine.genre=Quercus\")\n  y<-fromJSON(rawToChar((x$content)))\n  don<-y$records$fields\n  kable(don)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhauteurenm\ngeom_x_y\ncirconferenceencm\nstadedeveloppement\nremarquable\ngenre\npepiniere\ndateplantation\ntypeemplacement\narrondissement\nidemplacement\nlibellefrancais\ndomanialite\nadresse\nespece\nidbase\ncomplementadresse\n\n\n\n\n7\n48.868295, 2.363189\n53\nJeune (arbre)\nOUI\nQuercus\nGUILLOT BOURNE\n2017-11-09T01:00:00+00:00\nArbre\nPARIS 10E ARRDT\n000401009\nChêne\nAlignement\nPLACE DE LA REPUBLIQUE\ncerris\n2017817\nNA\n\n\n23\n48.818389, 2.437919\n255\nMature\nOUI\nQuercus\nInconnue\n1860-01-01T00:09:21+00:00\nArbre\nBOIS DE VINCENNES\n12-15\nChêne\nJardin\nPENTE DE GRAVELLE - AVENUE DE GRAVELLE / ROUTE NOUVELLE\nilex\n2002385\n12-15\n\n\n30\n48.834174, 2.461321\n431\nMature\nOUI\nQuercus\nInconnue\n1784-01-01T00:09:21+00:00\nArbre\nBOIS DE VINCENNES\n12-25\nChêne\nJardin\nLAC DES MINIMES - ROUTE RONDE DES MINIMES\nrobur\n2002376\n12-25\n\n\n10\n48.873681, 2.290252\n207\nMature\nOUI\nQuercus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 16E ARRDT\n000206003\nChêne\nJardin\nJARDIN DE L AVENUE FOCH / 10 AVENUE FOCH\nilex\n114867\nPELOUSE 10 - 20 à 26\n\n\n30\n48.843308, 2.449743\n465\nMature\nOUI\nQuercus\nInconnue\n1815-01-01T00:09:21+00:00\nArbre\nBOIS DE VINCENNES\n12-26\nChêne\nJardin\nFORT NEUF - AVENUE DE LA PEPINIERE / ROUTE DU GRAND MARECHAL\nrobur\n2002375\n12-26\n\n\n15\n48.833021, 2.349918\n140\nAdulte\nOUI\nQuercus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 13E ARRDT\n000301002\nChêne\nJardin\nSQUARE RENE LE GALL / 1 RUE EMILE DESLANDRES\ncerris\n104839\nRoseraie\n\n\n15\n48.839644, 2.300976\n180\nAdulte\nOUI\nQuercus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 15E ARRDT\n000106001\nChêne\nJardin\nSQUARE DE LA PLACE ADOLPHE CHERIOUX / 260 RUE DE VAUGIRARD\nfrainetto\n113597\nNA\n\n\n11\n48.847173, 2.252866\n232\nMature\nOUI\nQuercus\nInconnue\n1895-01-01T00:09:21+00:00\nArbre\nPARIS 16E ARRDT\n00040054\nChêne\nJardin\nJARDIN DES SERRES D AUTEUIL / 1 AVENUE GORDON BENNETT\nsuber subsp. Occidentalis\n136338\nNA\n\n\n13\n48.84657, 2.25242\n237\nMature\nOUI\nQuercus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 16E ARRDT\n00040039\nChêne\nJardin\nJARDIN DES SERRES D AUTEUIL / 1 AVENUE GORDON BENNETT\nilex\n136323\nNA\n\n\n15\n48.821839, 2.335786\n255\nMature\nOUI\nQuercus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 14E ARRDT\n0311B1011\nChêne\nJardin\nPARC MONTSOURIS / 28 BOULEVARD JOURDAN\nilex\n110934\nVolcan / Puits\n\n\n14\n48.838816, 2.406567\n169\nAdulte\nOUI\nQuercus\nInconnue\n1990-01-01T01:00:00+00:00\nArbre\nPARIS 12E ARRDT\n000202001\nChêne\nJardin\nSQUARE CHARLES PEGUY / 21 RUE ROTTEMBOURG\nfrainetto\n123156\nNA\n\n\n\n\n\n\n\nExclusion\nOn peut de la même manière exclure au lieu de sélectionner en utilisant l’instruction exclude. Par exemple, on peut retirer les deux bois de Vincennes et de Boulogne qui sont identifiés dans la variable arrondissement. Il ne rste plus alors que 130 arbres remarquables au lieu de 178.\n\nx<- GET(\"https://public.opendatasoft.com/api/records/1.0/search/?dataset=arbresremarquablesparis2011&q=&rows=1000&exclude.arrondissement=BOIS+DE+VINCENNES&exclude.arrondissement=BOIS+DE+BOULOGNE\")\n  y<-fromJSON(rawToChar((x$content)))\n  don<-y$records$fields\n dim(don)\n\n[1] 126  18\n\n table(don$arrondissement)\n\n\nPARIS 10E ARRDT PARIS 11E ARRDT PARIS 12E ARRDT PARIS 13E ARRDT PARIS 14E ARRDT \n              1               1               3               4              10 \nPARIS 15E ARRDT PARIS 16E ARRDT PARIS 17E ARRDT PARIS 18E ARRDT PARIS 19E ARRDT \n              6              27               8              10              10 \nPARIS 1ER ARRDT PARIS 20E ARRDT  PARIS 3E ARRDT  PARIS 4E ARRDT  PARIS 5E ARRDT \n              1              14               3               5               6 \n PARIS 6E ARRDT  PARIS 7E ARRDT  PARIS 8E ARRDT  PARIS 9E ARRDT \n              1               9               5               2 \n\n\n\n\nSélection géographique\nUne autre possibilité offerte par l’application est d’extraire des enregistrements en fonction d’une localisation géographique et d’une distance maximale à celle-ci. Supposons par exemple que l’on souhaite trouver l’ensemble des arbres remarquables dans un rayon de 2 km autour du bâtiment Olympe de Gouges situé place Paul Ricoeur dans le 13e arrondissement. Pour résoudre le problème, on commence par déterminer les coordonnées du lieu cible ce qui peut se faire par un click droit dans une Google Map :\n\nknitr::include_graphics(\"img/coord_odg.png\")\n\n\n\n\nOn passe ensuite une requête incluant le paramètre geofilter.distance()assortie des trois paramètres de latitude (en degré décimal), longitude (en degré décimal) et distance (en mètres) avec comme séparateur %2Cce qui donne au final un tableau ne comportant que 3 arbres remarquables à moins de deux kilomètres du point choisi :\n\nx<-GET(\"https://public.opendatasoft.com/api/records/1.0/search/?dataset=arbresremarquablesparis2011&q=&rows=1000&geofilter.distance=48.82670%2C2.38242%2C2000\")\n  y<-fromJSON(rawToChar((x$content)))\n  don<-y$records$fields\ndon <-don%>% select(adresse, libellefrancais, dist, hauteurenm, circonferenceencm)\nkable(don)\n\n\n\n\n\n\n\n\n\n\n\nadresse\nlibellefrancais\ndist\nhauteurenm\ncirconferenceencm\n\n\n\n\nPARC DE BERCY / 128 QUAI DE BERCY\nPlatane\n829.84776688445\n35\n502\n\n\nPARC DE CHOISY / 1 RUE GEORGE EASTMAN\nCèdre\n1699.294305054727\n25\n355\n\n\nJARDIN DE LA GARE DE REUILLY - JULIEN LAUPRETRE / 6 RUE PAUL DUKAS\nLibocèdre\n1728.7655425984415\n20\n205\n\n\n\n\n\n\n\nFonction\nNous pouvons alors créer une petite fonction qui va automatiquement sélectionner les arbres en fonction d’une coordonnée et d’une distance choisies par l’utilisateur :\n\nget_data_geo<-donnees<-function(idtab = \"arbresremarquablesparis2011\",\n                  rows=10,\n                  start=0,\n                  lat = 48.82670,\n                  lon = 2.38242,\n                  dist = 2000) {\n  url<-paste0(\"https://public.opendatasoft.com/api/records/1.0/search/?dataset=\",idtab,\n              \"&q=&rows=\",rows,\n              \"&start=\",start,\n              \"&geofilter.distance=\", lat,\"%2C\", lon,\"%2C\",dist,\n              sep=\"\")\n  \n  x<-GET(url)\n  y<-fromJSON(rawToChar((x$content)))\n  don<-y$records$fields\n  return(don)\n}\n\nNotre fonction est paramétrée par défaut sur la place Paul Ricoeur pour un rayon de 2000 mètres mais on peut ensuite changer les paramètres comme on le souhaite. On peut par exemple rechercher les arbres remarquables dans un rayon de 500 mètres autour de la cathédrale Notre Dame de Paris.\n\ntab<-get_data_geo(idtab = \"arbresremarquablesparis2011\",\n                  rows=1000,\n                  start=0,\n                  lat = 48.85331,\n                  lon = 2.34907,\n                  dist = 500)\nkable(tab)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhauteurenm\ngeom_x_y\ncirconferenceencm\nstadedeveloppement\nremarquable\ngenre\npepiniere\ndateplantation\ntypeemplacement\narrondissement\ncomplementadresse\nidemplacement\nlibellefrancais\ndomanialite\nadresse\nespece\nidbase\ndist\nvarieteoucultivar\n\n\n\n\n19\n48.852783, 2.351016\n210\nAdulte\nOUI\nCorylus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 4E ARRDT\n04-04\n000104001\nNoisetier de Byzance\nJardin\nSQUARE JEAN XXIII / 2 QUAI DE L ARCHEVECHE\ncolurna\n125046\n153.9816687873372\nNA\n\n\n9\n48.852191, 2.347286\n365\nMature\nOUI\nRobinia\nInconnue\n1602-01-01T00:09:21+00:00\nArbre\nPARIS 5E ARRDT\nNA\n000401001\nRobinier\nJardin\nSQUARE RENE VIVIANI MONTEBELLO / 2 RUE DU FOUARRE\npseudoacacia\n124358\n180.29215072419555\nNA\n\n\n10\n48.852102, 2.350804\n167\nAdulte\nOUI\nUlmus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 4E ARRDT\nNA\n000302002\nOrme\nJardin\nSQUARE JEAN XXIII / 2 QUAI DE L ARCHEVECHE\nglabra\n125063\n184.75764884140503\n‘’Pendula’’\n\n\n3\n48.85235, 2.35181\n230\nMature\nOUI\nTamarix\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 4E ARRDT\nNA\n000102002\nTamaris\nJardin\nSQUARE JEAN XXIII / 2 QUAI DE L ARCHEVECHE\nn. sp.\n125051\n226.86413517666327\nNA\n\n\n16\n48.855760, 2.353992\n190\nMature\nOUI\nUlmus\nInconnue\n1700-01-01T00:09:21+00:00\nArbre\nPARIS 4E ARRDT\n04-01\n000301001\nOrme\nAlignement\nPLACE SAINT GERVAIS\nminor\n267663\n451.4910432410224\nNA\n\n\n\n\n\nMais notre fonction peut également marcher pour d’autres tableaux si ceux-ci ont la même structure. On peut ainsi examiner les entreprises localisées à moins de 50 mètres du bâtiment d’Olympe de Gouges à l’aide de la base SIREN et on trouve 11 références :\n\ntab<-get_data_geo(idtab = \"sirene_v3\",\n                  rows=1000,\n                  start=0,\n                  lat = 48.82670,\n                  lon = 2.38242,\n                  dist = 50)\ntab<-tab %>% select(siret,l1_adressage_unitelegale, adresseetablissement,sectionetablissement,naturejuridiqueunitelegale)\nkable(tab)\n\n\n\n\n\n\n\n\n\n\n\nsiret\nl1_adressage_unitelegale\nadresseetablissement\nsectionetablissement\nnaturejuridiqueunitelegale\n\n\n\n\n84261103000011\nELIPS (ETUDIANTS DE LINGUISTIQUE INFORMATIQUE DE PARIS DIDEROT)\n8 PL PAUL RICOEUR\nAutres activites de services\nAssociation déclarée\n\n\n87776849900015\nGEOMIE\nPL PAUL RICOEUR\nAutres activites de services\nAssociation déclarée\n\n\n18750006101539\nCENTRE REGIONAL OEUVRES UNIV SCOLAIRES\n8 PL PAUL RICOEUR\nHebergement et restauration\nAutre établissement public national administratif à compétence territoriale limitée\n\n\n90059716200016\nINGENIEURS SANS FRONTIERES, EQUIPE DE L’UNIVERSITE DE PARIS\n8 PL PAUL RICOEUR\nAutres activites de services\nAssociation déclarée\n\n\n82868797000016\nJUNIOR EIDD CONSEIL\n8 PL PAUL RICOEUR\nActivites specialisees, scientifiques et techniques\nAssociation déclarée\n\n\n78887970800014\nSIMULAUTO\n9 RUE ALBERT EINSTEIN\nEnseignement\nSAS, société par actions simplifiée\n\n\n79378675700013\nPARIS PERMIS\n9 RUE ALBERT EINSTEIN\nEnseignement\nSociété à responsabilité limitée (sans autre indication)\n\n\n87973678300017\nMadame HELENE DUPLANTIER\n7 RUE ALBERT EINSTEIN\nArts, spectacles et activites recreatives\nEntrepreneur individuel\n\n\n84262529500014\nMadame JOANA FONSECA LEITAO\n7 RUE ALBERT EINSTEIN\nActivites de services administratifs et de soutien\nEntrepreneur individuel\n\n\n81325823300028\nCOMPAGNIE LES ENVOLEES\n7 RUE ALBERT EINSTEIN\nArts, spectacles et activites recreatives\nAssociation déclarée\n\n\n88086923500015\nSTREET BIDA\n1 RUE NICOLE REINE LEPAUTE\nHebergement et restauration\nSAS, société par actions simplifiée"
  },
  {
    "objectID": "11-API-OPENDATASOFT.html#exercice",
    "href": "11-API-OPENDATASOFT.html#exercice",
    "title": "L’API opendatasoft",
    "section": "Exercice",
    "text": "Exercice\nEssayez de récupérer les informations sur l’ensemble des ventes immobilières de maisons commune de Montcuq-en-Quercy-Blanc (Code Postal 46800) au cours de l’année 2020 puis calculés le prix moyen par m2 de\nbuildingref-france-demande-de-valeurs-foncieres-geolocalisee-millesime\n\n x<-GET(\"https://public.opendatasoft.com/api/records/1.0/search/?dataset=buildingref-france-demande-de-valeurs-foncieres-geolocalisee-millesime&q=montcuq&refine.date_mutation=2020&refine.type_local=Maison&rows=1000\")\n\nw<-rawToChar((x$content))\nd<-fromJSON(w)\nt<-d$records$fields\n\ndon<-t %>% select(surface_reelle_bati,surface_terrain,valeur_fonciere) %>% \n  mutate(prixm2 = valeur_fonciere/surface_reelle_bati)\n\nkable(don)\n\n\n\n\nsurface_reelle_bati\nsurface_terrain\nvaleur_fonciere\nprixm2\n\n\n\n\n60\n1258\n60000\n1000.0000\n\n\n50\n443\n190150\n3803.0000\n\n\n159\n367\n330000\n2075.4717\n\n\n137\n5566\n165000\n1204.3796\n\n\n100\n51\n45000\n450.0000\n\n\n140\n1205\n160000\n1142.8571\n\n\n100\n932\n150000\n1500.0000\n\n\n102\n910\n238000\n2333.3333\n\n\n50\n800\n121000\n2420.0000\n\n\n95\n71\n217250\n2286.8421\n\n\n324\n234\n510000\n1574.0741\n\n\n163\n225\n222000\n1361.9632\n\n\n70\n358\n82000\n1171.4286\n\n\n20\n31\n41800\n2090.0000\n\n\n71\n71\n110000\n1549.2958\n\n\n70\n137\n41800\n597.1429\n\n\n150\n327\n300000\n2000.0000\n\n\n99\n2460\n225000\n2272.7273\n\n\n148\n425\n278000\n1878.3784\n\n\n140\n1118\n370000\n2642.8571\n\n\n140\n610\n370000\n2642.8571\n\n\n77\n739\n107000\n1389.6104\n\n\n134\n365\n130000\n970.1493\n\n\n40\nNA\n18000\n450.0000\n\n\n140\n2080\n370000\n2642.8571\n\n\n210\n170\n535240\n2548.7619\n\n\n70\n271\n82000\n1171.4286\n\n\n64\n957\n103000\n1609.3750\n\n\n55\n38\n217250\n3950.0000\n\n\n100\n500\n150000\n1500.0000\n\n\n27\n1275\n187000\n6925.9259\n\n\n79\n1275\n187000\n2367.0886\n\n\n99\n500\n225000\n2272.7273\n\n\n148\n100\n278000\n1878.3784\n\n\n220\n1210\n335000\n1522.7273\n\n\n280\n450\n270000\n964.2857\n\n\n200\n1060\n225000\n1125.0000\n\n\n75\n1827\n106177\n1415.6933\n\n\n81\n1579\n146000\n1802.4691\n\n\n\n\nsummary(don)\n\n surface_reelle_bati surface_terrain  valeur_fonciere      prixm2    \n Min.   : 20.0       Min.   :  31.0   Min.   : 18000   Min.   : 450  \n 1st Qu.: 70.0       1st Qu.: 243.2   1st Qu.:108500   1st Qu.:1188  \n Median :100.0       Median : 500.0   Median :187000   Median :1609  \n Mean   :115.1       Mean   : 842.0   Mean   :202530   Mean   :1910  \n 3rd Qu.:144.0       3rd Qu.:1183.2   3rd Qu.:274000   3rd Qu.:2310  \n Max.   :324.0       Max.   :5566.0   Max.   :535240   Max.   :6926  \n                     NA's   :1                                       \n\nplot(don$surface_reelle_bati,don$valeur_fonciere)"
  },
  {
    "objectID": "21-CARTO-sf.html",
    "href": "21-CARTO-sf.html",
    "title": "CARTO-sf",
    "section": "",
    "text": "# packages utilitaires\nlibrary(knitr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(jsonlite)\n\n# Data packages\nlibrary(wbstats)\nlibrary(rnaturalearth)\n\n# Packages cartographiques\nlibrary(sf)\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\nlibrary(geojsonsf)\nlibrary(mapsf)\nL’importation et l’exportation de données spatiales peut se faire de différentes manières qui sont illustrées dans trois exemples. L’important est d’aboutir à un fichier de type sf (spatial features) combinant les données géométriques et les données statistiques dans un seul objet. Une fois créé, cet obet sera stocké au format interne de R (.RDS)."
  },
  {
    "objectID": "21-CARTO-sf.html#importation-dun-shapefile",
    "href": "21-CARTO-sf.html#importation-dun-shapefile",
    "title": "CARTO-sf",
    "section": "Importation d’un shapefile",
    "text": "Importation d’un shapefile\n\nCarte au format shapefile\nBeaucoup de fonds de cartes sont stockés au format shapefile, utilisé dans les systèmes d’information géographiques (SIG). Un shapefile se compose en réalité de trois ou quatre fichiers correspondant la géométrie (fic.shp), à la projection (fic.prj), aux données attributaires (fic.dbf), etc..\nOn charge le fonds de carte au format shapefile avec la fonction st_read() du package sf. On ne lui indique que le nom du fichier de géométrie et il lit automatiquement les autres.\n\nmap<-st_read(\"carto/europe88/euro1988_map.shp\")\n\nReading layer `euro1988_map' from data source \n  `/Users/claudegrasland1/git/datamining2023/carto/europe88/euro1988_map.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 25 features and 1 field\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 680158.7 ymin: 576113.9 xmax: 5609069 ymax: 4991631\nProjected CRS: ETRS89-extended / LCC Europe\n\n\nLe fichier est au format sf qui est le format cartographique de R. Il comporte une colonne spéciale appelée geometry.\n\nclass(map)\n\n[1] \"sf\"         \"data.frame\"\n\nhead(map)\n\nSimple feature collection with 6 features and 1 field\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 3496766 ymin: 1525952 xmax: 5448053 ymax: 2758691\nProjected CRS: ETRS89-extended / LCC Europe\n  ISO3                       geometry\n1  ALB MULTIPOLYGON (((4777759 184...\n2  AUT MULTIPOLYGON (((4494160 246...\n3  BEL MULTIPOLYGON (((3728385 267...\n4  BGR MULTIPOLYGON (((5260441 208...\n5  CHE MULTIPOLYGON (((3968843 232...\n6  CSK MULTIPOLYGON (((4327916 268...\n\n\nOn peut visualiser la carte enb effectuant un plot de la colonne geometry :\n\nplot(map$geometry)\n\n\n\n\n\n\nDonnées au format .csv\n\ndon<-read.table(\"carto/europe88/euro1988.csv\",\n                sep=\";\",\n                header=T,\n                encoding = \"UTF-8\")\nclass(don)\n\n[1] \"data.frame\"\n\nhead(don)\n\n  PAYS BLOC   PNB  TMI ESP URB NAT MOR FEC JEU VIE SUP  POP       X       Y\n1  ALB  Soc   600 43.0  71  34  27   6 3.3  35   5  29  3.1 4825115 1684833\n2  AUT  Cap 10000 10.3  75  55  12  12 1.4  18  14  84  7.6 4299715 2335579\n3  BEL  Cap  9200  9.7  75  95  12  11 1.5  19  14  31  9.9 3636312 2667243\n4  BGR  Soc  2000 14.5  72  65  13  11 2.0  21  11 111  9.0 5206070 1930219\n5  CHE  Cap 17800  6.8  77  61  12   9 1.5  17  14  41  6.6 3869378 2243130\n6  CSK  Soc  3200 13.9  71  74  14  12 2.0  24  11 128 15.6 4487005 2540281\n\n\n\n\nJointure\n\nmapdon<-merge(map,don,by.x=\"ISO3\",by.y=\"PAYS\",all.x=T,all.y=T)\nclass(mapdon)\n\n[1] \"sf\"         \"data.frame\"\n\nhead(mapdon)\n\nSimple feature collection with 6 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 3496766 ymin: 1525952 xmax: 5448053 ymax: 2758691\nProjected CRS: ETRS89-extended / LCC Europe\n  ISO3 BLOC   PNB  TMI ESP URB NAT MOR FEC JEU VIE SUP  POP       X       Y\n1  ALB  Soc   600 43.0  71  34  27   6 3.3  35   5  29  3.1 4825115 1684833\n2  AUT  Cap 10000 10.3  75  55  12  12 1.4  18  14  84  7.6 4299715 2335579\n3  BEL  Cap  9200  9.7  75  95  12  11 1.5  19  14  31  9.9 3636312 2667243\n4  BGR  Soc  2000 14.5  72  65  13  11 2.0  21  11 111  9.0 5206070 1930219\n5  CHE  Cap 17800  6.8  77  61  12   9 1.5  17  14  41  6.6 3869378 2243130\n6  CSK  Soc  3200 13.9  71  74  14  12 2.0  24  11 128 15.6 4487005 2540281\n                        geometry\n1 MULTIPOLYGON (((4777759 184...\n2 MULTIPOLYGON (((4494160 246...\n3 MULTIPOLYGON (((3728385 267...\n4 MULTIPOLYGON (((5260441 208...\n5 MULTIPOLYGON (((3968843 232...\n6 MULTIPOLYGON (((4327916 268...\n\n\n\n\nEssai de cartographie\nOn utilise ici la fonction d’affichage la plus basique …\n\nplot(mapdon[\"PNB\"])\n\n\n\n\n\n\nSauvegarde du fichier sf\n\nsaveRDS(mapdon,\"carto/europe88/europe88_sf.RDS\")"
  },
  {
    "objectID": "21-CARTO-sf.html#importation-à-laide-de-packages",
    "href": "21-CARTO-sf.html#importation-à-laide-de-packages",
    "title": "CARTO-sf",
    "section": "Importation à l’aide de packages",
    "text": "Importation à l’aide de packages\nNous allons essayer de constituer une carte des émissions de CO2 par habitant dans le Monde 2018 basée sur la combinaison des données wbstats et du fonds de carte gadm du package geodata.\n\nImportation du fonds de carte\nOn charge le fonds de carte des pays du Monde du package geodata\n\nlibrary(geodata)\nmap<-world(resolution=5, path=tempdir())\nworldmap<-st_as_sf(map)\nsaveRDS(worldmap, \"carto/world/worldmap.RDS\")\n\n\n\nImportation des données statistiques\nOn importe les données statistiques correspondant aux pays qui ont été retenus dans le fonds de carte. Pour cela on utilise l’API de la banque mondiale\n\nlibrary(wbstats)\ndf   <- wb_data(indicator  = c(\"SP.POP.TOTL\", \"EN.ATM.CO2E.KT\"),\n                return_wide = TRUE,\n                start_date = 2018,\n                end_date = 2018)\n\nNous renommons les variables pour avoir un tableau plus simple ou la population est en millions d’habitants, les émissions de CO2 en millions de tonnes. On y ajoute l’intensité des émissions en tonnes par habitant. Puis on sauvegarder le tout.\n\ndon <-df %>% select(iso3 = iso3c,  POP = SP.POP.TOTL, CO2 = EN.ATM.CO2E.KT) %>%\n            mutate(POP = POP/1000000, CO2 = CO2/1000, CO2_hab = CO2/POP)\nkable(head(don),digits = 2)\nsaveRDS(don, \"carto/world/worlddon.RDS\")\n\n\n\nJointure\nOn charge nos deux fichiers de cartes et de données. Comme ces fichiers comportent un même identifiant et un seul (iso3), on peut effectuer la jointure avec la fonction left_join() du package dplyr.\n\nmap<-readRDS(\"carto/world/worldmap.RDS\")\ndon<-readRDS(\"carto/world/worlddon.RDS\")\nmapdon <- merge(map, don, \n                by.x=\"GID_0\",\n                by.y=\"iso3\",\n                all.x=T,\n                all.y = F)\nkable(head(mapdon))\n\n\n\n\n\n\n\n\n\n\n\n\nGID_0\nNAME_0\nPOP\nCO2\nCO2_hab\ngeometry\n\n\n\n\nABW\nAruba\n0.105962\nNA\nNA\nPOLYGON ((-69.9782 12.46986…\n\n\nAFG\nAfghanistan\n36.686784\n6.07\n0.1654547\nPOLYGON ((74.89049 37.23569…\n\n\nAGO\nAngola\n31.273533\n23.96\n0.7661430\nMULTIPOLYGON (((23.9957 -10…\n\n\nALA\nÅland\nNA\nNA\nNA\nMULTIPOLYGON (((19.62865 60…\n\n\nALB\nAlbania\n2.866376\n5.11\n1.7827389\nPOLYGON ((20.03311 42.54832…\n\n\nAND\nAndorra\n0.075013\n0.49\n6.5322012\nPOLYGON ((1.721942 42.50123…\n\n\n\n\n\n\n\nEssai de cartographie\nOn réalise ici une belle carte avec le package mapsf qui sera expliqué plus loin\n\nlibrary(mapsf)\nmf_theme(\"agolalight\")\n  mf_map(x= mapdon,\n         var = \"CO2_hab\", \n         type = \"choro\",\n         breaks=\"jenks\",\n         leg_pos=\"bottomleft\",\n         leg_title = \"en tonnes/hab.\")\n  mf_map(x= mapdon,\n         var = \"CO2\",\n         type = \"prop\",\n         inches = 0.2,\n         col=\"red\",\n         leg_pos = \"topleft\",\n         leg_title = \"en millions de tonnes\")\n\n44 'NA' values are not plotted on the map.\n\nmf_title(\"Emissions de CO2 des pays du Monde en 2018\")\n\n\n\n\n\n\nSauvegarde du fichier sf\n\nsaveRDS(mapdon,\"carto/world/worldmapCO2.RDS\")"
  },
  {
    "objectID": "21-CARTO-sf.html#importation-au-format-geojson",
    "href": "21-CARTO-sf.html#importation-au-format-geojson",
    "title": "CARTO-sf",
    "section": "Importation au format GEOJSON",
    "text": "Importation au format GEOJSON\nLa plupart des API permettent de récupérer directement des fichiers combinant les données statistiques et cartographiques au format GEOJSON. Il suffit alors de les convertir au format sf en une seule opération, sans avoir besoin d’effectuer de jointure.\n\nRécupération d’un fichier GEOJSON\nOn commence par repérer une url permettant de récupérer un fichier de type GeoJSON. Puis on récupère le fichier et on l’enregistre à l’aide de la fonction dowload.file() en lui donnat l’extension .geojson. Ce fichier pourra être utilisé dans d’autres langages de programmation comme Python.\n\nmyurl<- \"https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets/georef-france-commune/exports/geojson?lang=fr&refine=reg_name%3A%22%C3%8Ele-de-France%22&timezone=Europe%2FBerlin\"\n\n\n\ndownload.file(url=myurl,\n              destfile=\"carto/idfcom/idfcom.geojson\", \n              method=\"curl\")\n\n\n\nConversion du fichier geojson au format sf\nOn convertit le fichier geojson au format sf à l’aide de la fonction geojson_sf()du package geojsonsf. On vérifie que le fichier est bien de la bonne classe\n\nmapdon<-geojson_sf(\"carto/idfcom/idfcom.geojson\")\nclass(mapdon)\n\n[1] \"sf\"         \"data.frame\"\n\n\n\n\nSélection des variables\nOn ne conserve que la colonne code et on ajoute une colonne département\n\nmapdon<-mapdon %>% select(com_code) %>% \n  mutate(com_code = substr(com_code,3,7),\n         depcode = substr(com_code,1,2))\nhead(mapdon)\n\nSimple feature collection with 6 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2.584831 ymin: 48.49468 xmax: 3.48622 ymax: 48.91068\nGeodetic CRS:  WGS 84\n  com_code                       geometry depcode\n1    77072 POLYGON ((3.411219 48.54254...      77\n2    77075 POLYGON ((2.775456 48.91034...      77\n3    77081 POLYGON ((2.738851 48.6351,...      77\n4    77151 POLYGON ((3.156655 48.6999,...      77\n5    77152 POLYGON ((2.641049 48.49468...      77\n6    77192 POLYGON ((2.896519 48.68125...      77\n\n\n\n\nEssai de cartographie\n\nplot(mapdon[\"depcode\"])\n\n\n\n\n\n\nSauvegarde au format sf\n\nsaveRDS(mapdon,\"carto/idfcom/idfcom.RDS\")"
  },
  {
    "objectID": "23-CARTO-leaflet.html#cartographie-de-polygones",
    "href": "23-CARTO-leaflet.html#cartographie-de-polygones",
    "title": "Carto-leaflet",
    "section": "Cartographie de polygones",
    "text": "Cartographie de polygones\nOn reprend l’exercice précédent mais en essayant de construire une cartographie par IRIS. L’exemple de départ est (comme toujours) celui de Sucy en Brie.\n\nExtraction des IRIS\nOn commence par charger le fonds de carte de la commune qui nous intéresse en précisant l’année car le découpage en IRIS change au cours du temps. On va prendre ici l’exemple du 13e arrondissement de Paris\n\nname <-\"Paris\"\nann <- 2020\n\n\nurl<-paste0(\"https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets/georef-france-iris-millesime/exports/geojson?lang=fr&refine=year%3A%22\",ann,\"%22&refine=com_name%3A%22\",name,\"%22\")\nmap_iris<-geojson_sf(url) %>% select(iris_code, iris_name)\nmap_iris$iris_code <- gsub('[\"','',map_iris$iris_code,fixed = T)\nmap_iris$iris_code <- gsub('\"]','',map_iris$iris_code,fixed = T)\nmap_iris$iris_name <- gsub('[\"','',map_iris$iris_name,fixed = T)\nmap_iris$iris_name <- gsub('\"]','',map_iris$iris_name,fixed = T)\nhead(map_iris)\n\nSimple feature collection with 6 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2.31039 ymin: 48.84052 xmax: 2.367835 ymax: 48.86372\nGeodetic CRS:  WGS 84\n  iris_code               iris_name                       geometry\n1 751010205            Les Halles 5 POLYGON ((2.348445 48.86238...\n2 751031101          Les Archives 1 POLYGON ((2.367252 48.86099...\n3 751051806    Jardin des Plantes 6 POLYGON ((2.35583 48.84158,...\n4 751062307 Notre-Dame des Champs 7 POLYGON ((2.325614 48.84566...\n5 751072501  Saint-Thomas d'Aquin 1 POLYGON ((2.325594 48.85588...\n6 751072699       Seine et Berges 2 POLYGON ((2.31166 48.86281,...\n\n# sélectin du 13e\nmap_iris <- map_iris %>% filter(substr(iris_code,1,5)==\"75113\")\nplot(map_iris$geometry)\n\n\n\n\n\n\nExtraction des dvf\nOn charge ensuite le fichier dvf des maisons et appartements de cette même commune au format geojson. On le nettoie pour ne garder que les ventes intéressantes. On remarque que les espaces sont remplacés par le code %20 dans l’URL.\n\nname <-\"Paris%2013e%20Arrondissement\"\n\nmyurl<-paste0(\"https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets/buildingref-france-demande-de-valeurs-foncieres-geolocalisee-millesime/exports/geojson?lang=fr&refine=com_name%3A%22\",name,\"%22\")  \nmap_dvf<-geojson_sf(myurl)\n\n\n\n\n# Select variable\nmap_dvf <-map_dvf %>% filter(nature_mutation ==\"Vente\",\n                             type_local %in% c(\"Maison\",\"Appartement\")) %>%\n                     mutate( id =id_mutation,\n                             ann = substr(id,1,4),\n                             typ = type_local,\n                             val = valeur_fonciere,\n                             sup = surface_reelle_bati,\n                             nbp = nombre_pieces_principales,\n                             prixm2 = val/sup)%>%\n                      select(id,ann,typ,val,sup,nbp,prixm2)\n\n# Eliminate duplicated id\nx<-table(map_dvf$id)\nduplic<-names(x[x>1])\nmap_dvf<-map_dvf %>% filter(!(id %in% duplic))\n\nhead(map_dvf)\n\nSimple feature collection with 6 features and 7 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2.346278 ymin: 48.82385 xmax: 2.372328 ymax: 48.82972\nGeodetic CRS:  WGS 84\n            id  ann         typ    val sup nbp    prixm2\n1 2014-1068919 2014 Appartement 800000  90   4  8888.889\n2 2014-1068925 2014 Appartement  88000  11   1  8000.000\n3 2014-1068944 2014 Appartement 100000  14   1  7142.857\n4 2014-1068964 2014 Appartement 313000  28   2 11178.571\n5 2014-1069188 2014 Appartement 365120  48   2  7606.667\n6 2014-1069190 2014 Appartement 650000 100   4  6500.000\n                   geometry\n1 POINT (2.346278 48.82972)\n2 POINT (2.367665 48.82956)\n3 POINT (2.371874 48.82439)\n4  POINT (2.372328 48.8279)\n5 POINT (2.359712 48.82597)\n6 POINT (2.349779 48.82385)\n\n# visualize\nplot(map_iris$geometry, col=\"lightyellow\",border=\"gray60\")\nplot(map_dvf$geometry,add=T,pch=20, col=\"blue\",cex=0.4)\n\n\n\n\n\n\nAjout du code iris au fichier dvf\nOn procède à une intersection entre les deux fonds de carte pour récupérer le code iris de chaque vente et on l’ajoute au fichier dvf.\n\nw<-as.numeric(st_intersects(map_dvf,map_iris))\nmap_dvf$iris_num<-w\ntab_iris<-st_drop_geometry(map_iris)\ntab_iris$iris_num<-1:length(tab_iris$iris_code)\nmap_dvf<-left_join(map_dvf,tab_iris) %>% filter(is.na(iris_code)==F)\nhead(map_dvf)\n\nSimple feature collection with 6 features and 10 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2.346278 ymin: 48.82385 xmax: 2.372328 ymax: 48.82972\nGeodetic CRS:  WGS 84\n            id  ann         typ    val sup nbp    prixm2 iris_num iris_code\n1 2014-1068919 2014 Appartement 800000  90   4  8888.889       64 751135120\n2 2014-1068925 2014 Appartement  88000  11   1  8000.000       30 751135025\n3 2014-1068944 2014 Appartement 100000  14   1  7142.857       16 751135011\n4 2014-1068964 2014 Appartement 313000  28   2 11178.571        1 751135014\n5 2014-1069188 2014 Appartement 365120  48   2  7606.667       14 751135105\n6 2014-1069190 2014 Appartement 650000 100   4  6500.000       60 751135111\n          iris_name                  geometry\n1 Maison Blanche 20 POINT (2.346278 48.82972)\n2           Gare 25 POINT (2.367665 48.82956)\n3           Gare 11 POINT (2.371874 48.82439)\n4           Gare 14  POINT (2.372328 48.8279)\n5  Maison Blanche 5 POINT (2.359712 48.82597)\n6 Maison Blanche 11 POINT (2.349779 48.82385)\n\n\n\n\nCréation d’indicateurs par IRIS\n\ntab_mai <- map_dvf %>% st_drop_geometry() %>% \n                               filter(typ == \"Maison\") %>%\n                               group_by(iris_code) %>%\n                               summarise(mai_nb = n(),\n                                         mai_sup_mean = mean(sup,na.rm=T),\n                                         mai_val_mean = mean(val,na.rm=T),\n                                         mai_nbp_mean = mean(nbp,na.rm=T),\n                                         mai_prixm2_med = median(prixm2,na.rm=T))\n\ntab_app <- map_dvf %>% st_drop_geometry() %>% \n                               filter(typ == \"Appartement\") %>%\n                               group_by(iris_code) %>%\n                               summarise(app_nb = n(),\n                                         app_sup_mean = mean(sup,na.rm=T),\n                                         app_val_mean = mean(val,na.rm=T),\n                                         app_nbp_mean = mean(nbp,na.rm=T),\n                                         app_prixm2_med = median(prixm2,na.rm=T))                            \nmap_iris <- map_iris %>% left_join(tab_mai) %>% left_join(tab_app)\n\n\n\nAffichage leaflet avec addPolygons()\nLa fonction leaflet de base pour tracer des polygones est addPolygons() qui est l’équivalent de addMarkers() que l’on a vu précédemment. Mais la différence importante est que l’on peut désormais fournir un fichier sf aux fonctions addPolygons et addMarkers puis accéder aux variables contenues dans ce fichier en utilisant un tilde ’~’suivi du nom de la variable.\nOn peut par exemple construire une carte des iris avec un label donnant le nom\n\n# centrage de la carte\n\n\n# Réalisation de la carte\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.83, lng=2.36, zoom = 14) %>% \n            addPolygons(data = map_iris,\n                        color = \"red\",\n                        label = ~iris_name)\nmap\n\n\n\n\n\nOn peut ajuster le tracé des lignes de contour et en régler l’épaisseur (weight=), la couleur (color =) ou l’opacité (opacity =). On peut de la même manière régler le remplissage des polygones en choisissant une autre couleur (fillColor =) et une opacité (fillOpacity=).\nOn peut évidemment superposer plusieurs couches de polygones comme on le montre ici en ajoutant le contour de la commune dont on ne trace que le contour (fill = FALSE)\n\nmap_com <- map_iris %>% summarise()\nnbiris<-dim(map_iris)[1]\nmycolors = rainbow(n=nbiris)\n\n# Réalisation de la carte\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.83, lng=2.36, zoom = 14) %>% \n            addPolygons(data = map_iris,\n                        color = \"white\",\n                        weight= 1,\n                        opacity = 0.4,\n                        fillColor = mycolors,\n                        fillOpacity = 0.3,\n                        label = ~iris_name) %>%\n             addPolygons(data = map_com,\n                         color=\"black\",\n                         weight =2,\n                         fill= FALSE)\n \nmap\n\n\n\n\n\n\n\nCartes choroplèthes aveccolorBin()\nDe la même manière que nous avons affiché une couleur différente dans chaque IRIS, nous pouvons proposer une carte choroplèthe et ajouter un popup donnant la valeur de l’indicateur si l’on clique. La seule difficulté est de préparer une palette de couleur à l’aide de l’une des fonction colorNumeric(), colorBin(), colorQuantile() ou colorFactor().\nVoyons un exemple sur la variable app_prixm2_med qui est le prix médian de vente des apparements.\n\n# Choix de la variable\n   myvar <-round(map_iris$app_prixm2_med,0)\n\n# Choix des classes \n    mycut<-c(5000, 6000, 7000, 8000,9000,10000, 11000)\n# Choix de la palette (c'est une fonction !)\n   mypal <- colorBin('YlOrRd', \n                       myvar,\n                       bins=mycut)\n\n\n# Réalisation de la carte\nmap <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.83, lng=2.36, zoom = 14) %>% \n            addPolygons(data = map_iris,\n                        fillColor = ~mypal(app_prixm2_med),\n                        fillOpacity = 0.5,\n                        color = \"white\",\n                        label = myvar,\n                    #    label = ~app_prixm2_med,\n #                       popup = mypop,\n                        weight = 1) %>%\n            addLegend(data = map_iris,\n                      pal = mypal, \n                      title = \"prix au m2\",\n                      values =~app_prixm2_med, \n                      position = 'topright') %>%\n             addPolygons(data = map_com,\n                         color=\"black\",\n                         weight =2,\n                         fill= FALSE)\n \nmap\n\n\n\n\n\n\n\nCartes de stock avec addCircleMarkers()\nNotre carte est intéressante mais elle ne permet pas de voir quelle est la quantité de vente qui a servi de base au calcul du prix médian\nNous allons donc superposer sur la carte précédente le nombre de ventes d’appartement. Puisqu’il s’agit d’un stock, nous devrons utiliser un figuré ponctuel avec une surface proportionnelle au nombre de ventes.\n\n# Choix de la variable\n   myvar <-round(map_iris$app_prixm2_med,0)\n\n# Choix des classes \n    mycut<-c(5000, 6000, 7000, 8000,9000,10000, 11000)\n# Choix de la palette (c'est une fonction !)\n   mypal <- colorBin('YlOrRd', \n                       myvar,\n                       bins=mycut)\n  \n   \n# Calcul du diamètre des cercles\n   myradius <-8*sqrt(map_iris$app_nb/max(map_iris$app_nb, na.rm=T))\n   \n# Calcul des centroides des iris\n   map_iris_ctr <-st_centroid(map_iris)\n\n   map <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.83, lng=2.36, zoom = 14) %>% \n            addPolygons(data = map_iris,\n                        fillColor = ~mypal(app_prixm2_med),\n                        fillOpacity = 0.5,\n                        color = \"white\",\n                        label = myvar,\n #                       popup = mypop,\n                        weight = 1) %>%\n            addLegend(data = map_iris,\n                      pal = mypal, \n                      title = \"prix médian au m2\",\n                      values =~app_prixm2_med, \n                      position = 'topright') %>%\n            addCircleMarkers(data=map_iris_ctr,\n                          #    lat = ~lat,\n                          #    lng = ~lng,\n                              radius = myradius,\n                              stroke = FALSE,\n                              label = ~app_nb,\n                              fillColor = \"gray50\",\n                              fillOpacity = 0.5)%>%\n             addPolygons(data = map_com,\n                         color=\"black\",\n                         weight =2,\n                         fill= FALSE)\n   \nmap\n\n\n\n\n\n\n\nLa cerise sur le gâteau …\nEt pour terminer notre belle carte, nous allons ajouter une fenêtre popup apportant à l’utilisateur tous les renseignements sur les appartements vendus chaque IRIS. Pour cela nous allons devoir construire chaque fenêtre popup au format HTML préalablement à l’affichage des cartes en utilisant des outils issus sdes packaghes htmltoolset htmlwidgets. On supprime les labels des deux couches, l’utilisateur ayant désormais juste à cliquer sur un Iris pour obtenir tous les renseignements dans une seule fenêtre\n\n# Choix de la variable\n   myvar <-round(map_iris$app_prixm2_med,0)\nsummary(myvar)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   5682    7820    8265    8254    8942   10526       8 \n\n# Choix des classes \n    mycut<-c(5000, 6000, 7000, 8000,9000,10000, 11000)\n# Choix de la palette (c'est une fonction !)\n   mypal <- colorBin('YlOrRd', \n                       myvar,\n                       bins=mycut)\n\n   \n# Calcul du diamètre des cercles\n   myradius <-8*sqrt(map_iris$app_nb/max(map_iris$app_nb, na.rm=T))\n   \n# Calcul des centroides des iris\n   map_iris_ctr <-st_centroid(map_iris)\n   \n# Préparation des popups\n      mypopups <- lapply(seq(nrow(map_iris)), function(i) {\n      paste0(  paste(\"Iris               : \" ,map_iris$iris_name[i]), '<br>', \n               paste(\"Nb. de ventes      : \" ,map_iris$app_nb[i]), '<br>', \n               paste(\"Prix de vente moyen: \" ,round(map_iris$app_val_mean[i],0)), '<br>',   \n               paste(\"Surface moyenne    : \" ,round(map_iris$app_sup_mean[i],0)), '<br>',    \n               paste(\"Nb. de pièces moyen: \" ,round(map_iris$app_nbp_mean[i],1)), '<br>',                  \n               paste(\"Prix au m2 médian  :\", round(map_iris$app_prixm2_med[i],0))\n            ) \n            })\n      mypopups<-lapply(mypopups, htmltools::HTML)\n   \n   \n\n   map <- leaflet() %>% \n            addProviderTiles('Esri.WorldTopoMap') %>%\n            setView(lat = 48.83, lng=2.36, zoom = 13) %>% \n            addPolygons(data = map_iris,\n                        fillColor = ~mypal(app_prixm2_med),\n                        fillOpacity = 0.5,\n                        color = \"white\",\n#                        label = ~app_prixm2_med,\n                        popup = mypopups,\n                        weight = 1) %>%\n            addLegend(data = map_iris,\n                      pal = mypal, \n                      title = \"prix médian au m2\",\n                      values =~app_prixm2_med, \n                      position = 'topright') %>%\n            addCircleMarkers(data=map_iris_ctr,\n                          #    lat = ~lat,\n                          #    lng = ~lng,\n                              radius = myradius,\n                              stroke = FALSE,\n#                              label = ~app_nb,\n                              fillColor = \"gray50\",\n                              fillOpacity = 0.5)%>%\n             addPolygons(data = map_com,\n                         color=\"black\",\n                         weight =2,\n                         fill= FALSE)\n   \nmap"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DataMining2023",
    "section": "",
    "text": "Ce document est la troisième version d’un cours de Data Mining dispensé aux étudiants de deuxième année de l’ option Data Mining du master MECI .\nIl est basé sur R version 4.2.2 (2022-10-31).\nCe document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse :\n\nhttps://claudegrasland.github.io/datamining2023/.\n\nPour toute suggestion ou correction, il est possible de me contacter par mail"
  },
  {
    "objectID": "index.html#prérequis",
    "href": "index.html#prérequis",
    "title": "DataMining2023",
    "section": "Prérequis",
    "text": "Prérequis\nLe seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux.\nPour installer R, il suffit de se rendre sur une des pages suivantes 1 :\n\nInstaller R sous Windows\nInstaller R sous Mac\n\nPour installer RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système :\n\nhttps://www.rstudio.com/products/rstudio/download/#download"
  },
  {
    "objectID": "index.html#remerciements",
    "href": "index.html#remerciements",
    "title": "DataMining2023",
    "section": "Remerciements",
    "text": "Remerciements\nCe document a bénéficié de la relecture et des suggestions … des étudiants qui en ont été les cobayes des premières versions."
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "DataMining2023",
    "section": "Licence",
    "text": "Licence\nCe document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International.\n\n\n\nLicence Creative Commons"
  },
  {
    "objectID": "XX-PROJ-Carto1.html",
    "href": "XX-PROJ-Carto1.html",
    "title": "PROJET-Carto1",
    "section": "",
    "text": "On se propose dans ce module d’apprendre à cartographier les données relatives aux ventes des maisons ou appartement par commune. On utilisera pour cela le package mapsf afin de produire des cartes thématiques combinant des variables de stock (e.g. nombre de ventes de maisons) et des variables de taux (e.g. prix de vente moyen des maisons au m2).\n\nlibrary(knitr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(reshape2)\nlibrary(sf)\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\nlibrary(mapsf)"
  },
  {
    "objectID": "XX-PROJ-Carto1.html#a.-agregation-par-commune",
    "href": "XX-PROJ-Carto1.html#a.-agregation-par-commune",
    "title": "PROJET-Carto1",
    "section": "A. AGREGATION PAR COMMUNE",
    "text": "A. AGREGATION PAR COMMUNE\nLa première étape du travail consiste à agréger les données de vente par commune en utilisant le code INSEE qui permettra par la suite de faire la jointure avec un fonds de carte.\n\nA.1 Nettoyage du fichier dvf\nOn charge le fichier dvf et on procède aux opérations de nettoyage nécéssaires (Cf. cours de Camille Signoretto).\n\n# Chargement\ndvf <- read.csv2(\"base/dvf_etudiants_V2.csv\")\n####  Selection et recodage \n\n# identifiant unique\nid<-dvf$Identifiant.de.mutation..Etalab.\n\n# année => factor\nann <-  substr(dvf$Date.de.la.mutation,1,4)\ntable(ann)\n\n# type => factor\ntype <- as.factor(dvf$Type.de.local)\n#levels(type)<-c(\"Appart\",\"Appart\",\"Appart\",\"Maison\")\ntable(type)\n\n# code de la commune \ncode <-as.character(dvf$Code.INSEE.de.la.commune)\nhead(table(code))\n\n# nom de la commune\nnom <- dvf$Nom.de.la.commune\n\n# surf => numeric\nsurf <- as.numeric(dvf$Surface.réelle.du.bâti)\n\n# nbpp => integer\nnbp <- as.integer(dvf$Nombre.de.pièces.principales)\n\n# prix => numeric\nprix <- as.numeric(dvf$Valeur.foncière)\n\n#### Assemblage\ndon<-data.frame(id,ann, code, nom, type, surf, nbp, prix)\n\n### ajout de variables\ndon$prixm2 <- don$prix/don$surf\n\n### elimination des données incomplètes\ndon<-don[complete.cases(don),]\n\n### elimination des valeurs aberrantes de prix/m2\nprixm2min <- quantile(don$prixm2,0.01)\nprixm2max <- quantile(don$prixm2,0.99)\nsurfmin<-quantile(don$surf,0.01)\nsurfmax<-quantile(don$surf,0.99)\nnbpmax <-quantile(don$nbp,0.99)\n\ndon <- don %>% filter(prixm2>prixm2min,\n                      prixm2 <prixm2max,\n                      surf > surfmin,\n                      surf < surfmax,\n                      nbp <= nbpmax)\n\n## Selection de Paris et Petite Couronne\ndon$dep <-substr(don$code,1,2)\ndon <- don %>% filter(don$dep %in% c(\"75\",\"92\",\"93\",\"94\"))\n\n### résumé\nsummary(don)\n\n### Sauvegarde\nsaveRDS(don,\"projet/dvf/dvfclean_V2.RDS\")\n\n\n\nA.2 Calcul d’effectifs par commune\nL’agrégation des variables qualitatives comme le type maison ou appartement s’effectue par simple comptage à l’aide de la fonction n(). On peut calculer les stocks d’un type précis :\n\ndon <- readRDS(\"projet/dvf/dvfclean_V2.RDS\")\nnb_maison <- don %>% filter(type == \"Maison\") %>%\n                        group_by(code) %>% \n                        summarise(Maison = n())\nhead(nb_maison)\n\n# A tibble: 6 × 2\n  code  Maison\n  <chr>  <int>\n1 75105      9\n2 75106      3\n3 75107      4\n4 75108      2\n5 75109      2\n6 75112      6\n\nnb_appart <- don %>% filter(type == \"Appartement\") %>%\n                        group_by(code) %>% \n                        summarise(Appart = n())  \n head(nb_appart)\n\n# A tibble: 6 × 2\n  code  Appart\n  <chr>  <int>\n1 75101   1770\n2 75102   2645\n3 75103   3241\n4 75104   2296\n5 75105   3666\n6 75106   3447\n\n\nOn peut également calculer d’un seul coup les stocks de différents types ce qui est plus efficace. Mais il faut alors pivoter le tableau pour redisposer les modalités en colonne.\n\n# Agrégation\nnb_type <- don %>% group_by(code, type) %>%\n                   summarise(nb=n()) \n\n`summarise()` has grouped output by 'code'. You can override using the\n`.groups` argument.\n\n# Pivotage \nnb_type <-  dcast(nb_type,\n                  formula = code~type,\n                  fill = 0, \n                  value.var = \"nb\" )\n# Nom de la variable\nnames(nb_type) <- c(\"code\",\"Appart_nb\",\"Maison_nb\")\nhead(nb_type)\n\n   code Appart_nb Maison_nb\n1 75101      1770         0\n2 75102      2645         0\n3 75103      3241         0\n4 75104      2296         0\n5 75105      3666         9\n6 75106      3447         3\n\n\n\n\nA.3 Sommes de volumes\nA la différence des effectifs, les volumes impliquent d’effectuer la somme de quantités. On va par exemple calculer le montant total des surfaces de logement ou le montant total des prix de ventes en séparant maisons et appartements.\n\n# Agrégation\nsurf_tot <- don %>% group_by(code,  type) %>%\n                   summarise(nb=sum(surf)) \n\n`summarise()` has grouped output by 'code'. You can override using the\n`.groups` argument.\n\n# Pivotage \nsurf_tot <-  dcast(surf_tot,\n                  formula = code~type,\n                  fill = 0, \n                  value.var = \"nb\" )\n# Nom de la variable\nnames(surf_tot) <- c(\"code\",\"Appart_surf_tot\",\"Maison_surf_tot\")\nhead(surf_tot)\n\n   code Appart_surf_tot Maison_surf_tot\n1 75101           74447               0\n2 75102          100602               0\n3 75103          132466               0\n4 75104           95603               0\n5 75105          141190            1095\n6 75106          165464             269\n\n\n\n# Agrégation\nprix_tot <- don %>% group_by(code,  type) %>%\n                   summarise(nb=sum(prix)) \n\n`summarise()` has grouped output by 'code'. You can override using the\n`.groups` argument.\n\n# Pivotage \nprix_tot <-  dcast(prix_tot,\n                  formula = code~type,\n                  fill = 0, \n                  value.var = \"nb\" )\n# Nom de la variable\nnames(prix_tot) <- c(\"code\",\"Appart_prix_tot\",\"Maison_prix_tot\")\nhead(prix_tot)\n\n   code Appart_prix_tot Maison_prix_tot\n1 75101      1044977268               0\n2 75102      1122946993               0\n3 75103      1602176390               0\n4 75104      1366842393               0\n5 75105      1804508247        12681412\n6 75106      2537909324         6110000\n\n\nSi on effectue la jointure de ces fichier avec le fichier précédent, on pourra calculer la moyenne pondérée des surfaces des maisons ou des appartements ainsi que la moyenne pondérée des prix de vente au mètre carré.\n\ntab<-nb_type %>% left_join(surf_tot) %>%\n                 left_join(prix_tot) %>%\n                 mutate(Maison_surf_moy = Maison_surf_tot/Maison_nb,\n                        Appart_surf_moy = Appart_surf_tot/Appart_nb,\n                        Maison_prix_moy = Maison_prix_tot/Maison_nb,\n                        Appart_prix_moy = Appart_prix_tot/Appart_nb)\n\nJoining with `by = join_by(code)`\nJoining with `by = join_by(code)`\n\n\n\n\nA.4 Agrégation statistique\nLa moyenne pondérée n’est pas toujours l’option la plus intéressante puisqu’elle accord plus de poids aux ventes des biens les plus importants. On peut préférer une méthode ou chaque bien est considéré comme d’importance égale. On peut alors calculer des indicateurs tels que la médiane ou les quartiles des prix de vente au mètre carré. On pourra alors mieux cibler l’hétérogénéité des communes.\n\n# Prix  au m2 / médiane\nprixm2_med <- don %>% group_by(code,  type) %>%\n                   summarise(nb=median(prixm2, na.rm=T)) \n\n`summarise()` has grouped output by 'code'. You can override using the\n`.groups` argument.\n\nprixm2_med <-  dcast(prixm2_med,\n                  formula = code~type,\n                  fill = NA, \n                  value.var = \"nb\" )\nnames(prixm2_med) <- c(\"code\",\"Appart_prixm2_mediane\",\"Maison_prixm2_mediane\")\n\n# Prix au m2 / premier quartile\nprixm2_Q1 <- don %>% group_by(code,  type) %>%\n                   summarise(nb=quantile(prixm2, 0.25, na.rm=T)) \n\n`summarise()` has grouped output by 'code'. You can override using the\n`.groups` argument.\n\nprixm2_Q1 <-  dcast(prixm2_Q1,\n                  formula = code~type,\n                  fill = NA, \n                  value.var = \"nb\" )\nnames(prixm2_Q1) <- c(\"code\",\"Appart_prixm2_Q1\",\"Maison_prixm2_Q1\")\n\n# Prix au m2 / troisième quartile\nprixm2_Q3 <- don %>% group_by(code,  type) %>%\n                   summarise(nb=quantile(prixm2, 0.75, na.rm=T)) \n\n`summarise()` has grouped output by 'code'. You can override using the\n`.groups` argument.\n\nprixm2_Q3 <-  dcast(prixm2_Q3,\n                  formula = code~type,\n                  fill = NA, \n                  value.var = \"nb\" )\nnames(prixm2_Q3) <- c(\"code\",\"Appart_prixm2_Q3\",\"Maison_prixm2_Q3\")\n\n\n\n## Assemblage\ntab<-tab %>% left_join(prixm2_med) %>%\n             left_join(prixm2_Q1) %>%\n              left_join(prixm2_Q3) \n\nJoining with `by = join_by(code)`\nJoining with `by = join_by(code)`\nJoining with `by = join_by(code)`\n\n\n\n\nA.5 Jointure avec le fonds de carte\nOn charge un fonds de carte des communes disposant du code INSEE, on effectue la jointure et on sauve le résultat.\n\nmapcom<-readRDS(\"projet/geom/map_com.RDS\")\nnames(mapcom)<-c(\"code\",\"nom\",\"geometry\")\nmapcomdvf<-left_join(mapcom,tab)\n\nJoining with `by = join_by(code)`\n\nsaveRDS(mapcomdvf,\"projet/mapcomdvf.RDS\")"
  },
  {
    "objectID": "XX-PROJ-Carto1.html#b.-cartographie",
    "href": "XX-PROJ-Carto1.html#b.-cartographie",
    "title": "PROJET-Carto1",
    "section": "B. CARTOGRAPHIE",
    "text": "B. CARTOGRAPHIE\nOn reprend le cours sur mapsf et on l’applique aux données dvf. On commence par charger le fonds de carte avec les données dvf et on ajoute un fonds de carte départemental à superposer par dessus :\n\nmap_com<-readRDS(\"projet/mapcomdvf.RDS\")\nmap_dep<-readRDS(\"projet/geom/map_dep.RDS\")\n\n\nCarte de stock minimale\nLes instructions minimales sont les suivantes :\n\n# Trace les contours des communes\nmf_map(x= map_com, \n       type = \"base\")\n\n\n# Ajoute le nombre de ventes de maison\nmf_map(x =map_com, \n      type =\"prop\",\n      var = \"Maison_nb\",\n      add=TRUE)\n\n6 '0' values are not plotted on the map.\n\n\n\n\n\nMais le résultat est peu satisfaisant car les cercles sont trop grands. Il faut en pratique toujours effectuer un réglage de ceux-ci avec l’instruction inches=\n\n\nCarte de stock habillée\nOn obtient une carte évidemment plus satisfaisante en effectuant une série de réglages :\n\nmf_theme(\"agolalight\")\nmf_map(map_com, type = \"base\",  \n       col = \"lightyellow\",border=\"gray80\", lwd=0.3)\nmf_map(map_dep, \n       type = \"base\", \n       col = NA,\n       border=\"black\",\n       lwd=1,\n       add = TRUE)\n\nmf_map(map_com, \n       var = \"Maison_nb\",\n       type = \"prop\",\n       inches = 0.1, \n       col = \"red\",\n       leg_pos = \"topleft\",  \n       leg_title = \"Nombre de ventes\",\n       add=TRUE)\n\n6 '0' values are not plotted on the map.\n\nmf_layout(title = \"Ventes de maison 2017-2021\", \n          arrow = F,\n          frame = TRUE,\n          credits = \"Sources : DVF & IGN\")\n\n\n\n\n\n\nComparaison de cartes de stock\nOn peut mettre en regard les deux cartes de stock des ventes de maison et d’appartement. Dans ce cas on utilise le paramètre val_max = pour donner une taille proportionnelle aux stocks de chacune des deux cartes.\n\n# Coupe la page en 2 colonnes\npar(mfrow=c(1,2))\n\n# Carte des maisons\nmf_theme(\"agolalight\")\nmf_map(map_com, type = \"base\",  \n       col = \"lightyellow\",border=\"gray80\", lwd=0.3)\nmf_map(map_dep, \n       type = \"base\", \n       col = NA,\n       border=\"black\",\n       lwd=1,\n       add = TRUE)\n\nmf_map(map_com, \n       var = \"Maison_nb\",\n       type = \"prop\",\n       inches = 0.1, \n       val_max = 15000,\n       col = \"red\",\n       leg_pos = \"topleft\",  \n       leg_title = \"Nombre de ventes 2017-2021\",\n       add=TRUE)\n\n6 '0' values are not plotted on the map.\n\nmf_layout(title = \"Maisons\", \n          frame = TRUE,\n          arrow=F,\n          credits = \"Sources : DVF & IGN\")\n\n# Carte des appartements\nmf_theme(\"agolalight\")\nmf_map(map_com, type = \"base\",  \n       col = \"lightyellow\",border=\"gray80\", lwd=0.3)\nmf_map(map_dep, \n       type = \"base\", \n       col = NA,\n       border=\"black\",\n       lwd=1,\n       add = TRUE)\n\nmf_map(map_com, \n       var = \"Appart_nb\",\n       type = \"prop\",\n       val_max = 15000,\n       inches = 0.1, \n       col = \"blue\",\n       leg_pos = \"topleft\",  \n       leg_title = \"Nombre de ventes 2017-2021\",\n       add=TRUE)\n\nmf_layout(title = \"Appartements\", \n          frame = TRUE,\n          arrow=F,\n          credits = \"Sources : DVF & IGN\")\n\n\n\n\n\nCommentaire : La carte finale permet de bien mettre en évidence le fait que les ventes d’appartements sont beaucoup plus nombreuses que celle des maisons. Mais elle montre aussi l’existence d’un gradient centre-périphérie avec l’accroissement progressif de la part des maisons par rapport aux appartements.\n\n\n\nCarte choroplèthe minimale\nOn prend comme exemple la médiane du prix de vente au m2\n\n# Carte choroplèthe\nmf_map(\n  x = map_com, \n  var = \"Appart_prixm2_mediane\",\n  type = \"choro\")\n\n\n\n\n\n\nCarte choroplèthe habillée\nOn peut arriver à une carte beaucoup plus satisfaisante en contrôlant l’ensemble des paramètres de couleur et de découpage des classes. Puis en superposant les contours des départements au dessus de la carte des communes pour faciliter le repérage.\n\n# Choisir les classes et la palette\nmybreaks = c(1000, 2000,3000,4000,5000,6000,7000,8000,9000,10000, 14000)\nmypal <- mf_get_pal(n = c(5, 5), pal = c(\"Greens\", \"Reds\"))\n# Tracer la carte choroplèthe\nmf_map( map_com,\n        var = \"Appart_prixm2_mediane\",\n        type = \"choro\",\n        breaks = mybreaks,\n        pal = mypal,\n        border=\"gray70\",\n        col_na = \"gray80\",\n        leg_title = \"en euros / m2\",\n        leg_val_rnd = 0)\n# Ajouter les contours des départements\nmf_map(map_dep,\n       type = \"base\",\n       col = NA,\n       border=\"black\",\n       lwd=1,\n       add = TRUE)\n# Ajouter un cadre, un titre et des sources\nmf_layout(title = \"Prix de vente médian des appartements 2017-2021\", \n          frame = TRUE,\n          credits = \"Sources : IGN et DVF\")\n\n\n\n\n\n\nComparaison de cartes choroplèthes\nOn peut mettre en regard les deux cartes de prix moyen au m2 des appartements et des maisons en utilisant les mêmes limites de classe. On retirera toutefois les communes ou arrondissements dans lesquels moins de 10 maisons ont été vendues afin d’éviter des fluctuations aléatoires.\n\npar(mfrow = c(1,2))\n# Choisir les classes et la palette\nmybreaks = c(1000, 2000,3000,4000,5000,6000,7000,8000,9000,10000, 14000)\nmypal <- mf_get_pal(n = c(5, 5), pal = c(\"Greens\", \"Reds\"))\n\n# Carte des maisons\nmap_com2 <- map_com\nmap_com2$Maison_prixm2_mediane[map_com2$Maison_nb<10]<-NA\nmf_map( map_com2,\n        var = \"Maison_prixm2_mediane\",\n        type = \"choro\",\n        breaks = mybreaks,\n        pal = mypal,\n        border=\"gray50\",\n        col_na = \"gray80\",\n        leg_title = \"en euros / m2\",\n        leg_val_rnd = 0)\nmf_map(map_dep,\n       type = \"base\",\n       col = NA,\n       border=\"black\",\n       lwd=1,\n       add = TRUE)\nmf_layout(title = \"Prix des maisons\", \n          frame = TRUE,\n          arrow=F,\n          credits = \"Sources : IGN et DVF\")\n\n# Carte des appartements\nmf_map( map_com,\n        var = \"Appart_prixm2_mediane\",\n        type = \"choro\",\n        breaks = mybreaks,\n        pal = mypal,\n        border=\"gray50\",\n        col_na = \"gray80\",\n        leg_title = \"en euros / m2\",\n        leg_val_rnd = 0)\nmf_map(map_dep,\n       type = \"base\",\n       col = NA,\n       border=\"black\",\n       lwd=1,\n       add = TRUE)\nmf_layout(title = \"Prix des appartements\", \n          arrow=F,\n          frame = TRUE,\n          credits = \"Sources : IGN et DVF\")\n\n\n\n\n\nCommentaire : Les maisons sont en général plus chères que les appartements mais la géographie des deux distributions est très comparable."
  }
]